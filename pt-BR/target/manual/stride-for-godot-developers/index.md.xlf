<?xml version="1.0" encoding="UTF-8" standalone="no"?><xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" xmlns:okp="okapi-framework:xliff-extensions" its:version="2.0" version="1.2">
<file datatype="x-text/x-markdown" okp:inputEncoding="UTF-8" original="/D:/repos/rr/source/manual/stride-for-godot-developers/index.md" source-language="en" target-language="pt">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">Stride for Godot developers</source>
<target xml:lang="pt">Stride for Godot developers</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">Editor</source>
<target xml:lang="pt">Editor</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Terminology</source>
<target xml:lang="pt">Terminology</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Scene</source>
<target xml:lang="pt">Scene</target>
</trans-unit>
<trans-unit id="tu7" xml:space="preserve">
<source xml:lang="en">Entity Tree</source>
<target xml:lang="pt">Entity Tree</target>
</trans-unit>
<trans-unit id="tu8" xml:space="preserve">
<source xml:lang="en">Inspector</source>
<target xml:lang="pt">Inspector</target>
</trans-unit>
<trans-unit id="tu9" xml:space="preserve">
<source xml:lang="en">Property Grid</source>
<target xml:lang="pt">Property Grid</target>
</trans-unit>
<trans-unit id="tu10" xml:space="preserve">
<source xml:lang="en">FileSystem</source>
<target xml:lang="pt">FileSystem</target>
</trans-unit>
<trans-unit id="tu11" xml:space="preserve">
<source xml:lang="en">Solution/Asset View</source>
<target xml:lang="pt">Solution/Asset View</target>
</trans-unit>
<trans-unit id="tu12" xml:space="preserve">
<source xml:lang="en">Scene view</source>
<target xml:lang="pt">Scene view</target>
</trans-unit>
<trans-unit id="tu13" xml:space="preserve">
<source xml:lang="en">Scene Editor</source>
<target xml:lang="pt">Scene Editor</target>
</trans-unit>
<trans-unit id="tu14" xml:space="preserve">
<source xml:lang="en">Node</source>
<target xml:lang="pt">Node</target>
</trans-unit>
<trans-unit id="tu15" xml:space="preserve">
<source xml:lang="en">Entity</source>
<target xml:lang="pt">Entity</target>
</trans-unit>
<trans-unit id="tu16" xml:space="preserve">
<source xml:lang="en">Node Script</source>
<target xml:lang="pt">Node Script</target>
</trans-unit>
<trans-unit id="tu17" xml:space="preserve">
<source xml:lang="en">SyncScript, AsyncScript, StartupScript</source>
<target xml:lang="pt">SyncScript, AsyncScript, StartupScript</target>
</trans-unit>
<trans-unit id="tu18" xml:space="preserve">
<source xml:lang="en">Export</source>
<target xml:lang="pt">Export</target>
</trans-unit>
<trans-unit id="tu19" xml:space="preserve">
<source xml:lang="en">Serialize/DataMember</source>
<target xml:lang="pt">Serialize/DataMember</target>
</trans-unit>
<trans-unit id="tu20" xml:space="preserve">
<source xml:lang="en">GlobalClass</source>
<target xml:lang="pt">GlobalClass</target>
</trans-unit>
<trans-unit id="tu21" xml:space="preserve">
<source xml:lang="en">DataContract</source>
<target xml:lang="pt">DataContract</target>
</trans-unit>
<trans-unit id="tu22" xml:space="preserve">
<source xml:lang="en">Folders and files</source>
<target xml:lang="pt">Folders and files</target>
</trans-unit>
<trans-unit id="tu23" xml:space="preserve">
<source xml:lang="en"><g id="1">Assets</g></source>
<target xml:lang="pt"><g id="1">Assets</g></target>
</trans-unit>
<trans-unit id="tu24" xml:space="preserve">
<source xml:lang="en">In Godot you can store assets everywhere.</source>
<target xml:lang="pt">In Godot you can store assets everywhere.</target>
</trans-unit>
<trans-unit id="tu25" xml:space="preserve">
<source xml:lang="en">In Stride Assets are in the Assets Folder</source>
<target xml:lang="pt">In Stride Assets are in the Assets Folder</target>
</trans-unit>
<trans-unit id="tu26" xml:space="preserve">
<source xml:lang="en">Stride and Godot use the Standard C# Solution Structure. Key difference here is that Stride uses the multi Project architecture which leads to the following Projects</source>
<target xml:lang="pt">Stride and Godot use the Standard C# Solution Structure. Key difference here is that Stride uses the multi Project architecture which leads to the following Projects</target>
</trans-unit>
<trans-unit id="tu27" xml:space="preserve">
<source xml:lang="en"><g id="1">MyPackage.Game</g> contains your source code.</source>
<target xml:lang="pt"><g id="1">MyPackage.Game</g> contains your source code.</target>
</trans-unit>
<trans-unit id="tu28" xml:space="preserve">
<source xml:lang="en"><g id="1">MyPackage.Platform</g> contains additional code for the platforms your project supports. Game Studio creates folders for each platform (eg <g id="2">MyPackage.Windows</g>, <g id="3">MyPackage.Linux</g>, etc). These folders are usually small, and only contain the entry point of the program.</source>
<target xml:lang="pt"><g id="1">MyPackage.Platform</g> contains additional code for the platforms your project supports. Game Studio creates folders for each platform (eg <g id="2">MyPackage.Windows</g>, <g id="3">MyPackage.Linux</g>, etc). These folders are usually small, and only contain the entry point of the program.</target>
</trans-unit>
<trans-unit id="tu29" xml:space="preserve">
<source xml:lang="en">And any other Subprojects. Stride will scan the Subprojects too like the main Project to get DataContract classes and features into the Editor/Game ( it doesn't matter if its in a subproject or not</source>
<target xml:lang="pt">And any other Subprojects. Stride will scan the Subprojects too like the main Project to get DataContract classes and features into the Editor/Game ( it doesn't matter if its in a subproject or not</target>
</trans-unit>
<trans-unit id="tu30" xml:space="preserve">
<source xml:lang="en"><g id="1">Bin:</g> contains the compiled binaries and data. Stride creates the folder when you build the project, with a subdirectory for each platform.</source>
<target xml:lang="pt"><g id="1">Bin:</g> contains the compiled binaries and data. Stride creates the folder when you build the project, with a subdirectory for each platform.</target>
</trans-unit>
<trans-unit id="tu31" xml:space="preserve">
<source xml:lang="en"><g id="1">obj:</g> contains cached files. Game Studio creates this folder when you build your project. To force a complete asset and code rebuild, delete this folder and build the project again.</source>
<target xml:lang="pt"><g id="1">obj:</g> contains cached files. Game Studio creates this folder when you build your project. To force a complete asset and code rebuild, delete this folder and build the project again.</target>
</trans-unit>
<trans-unit id="tu32" xml:space="preserve">
<source xml:lang="en"><g id="1">Resources:</g> is a suggested location for files such as images and audio files used by your assets, do not confuse them with Godot resources, these don't exist in Stride. Stride has in the Scene Folders (these can be used in any way) where you can put classes that would be normally Godot Resources</source>
<target xml:lang="pt"><g id="1">Resources:</g> is a suggested location for files such as images and audio files used by your assets, do not confuse them with Godot resources, these don't exist in Stride. Stride has in the Scene Folders (these can be used in any way) where you can put classes that would be normally Godot Resources</target>
</trans-unit>
<trans-unit id="tu33" xml:space="preserve">
<source xml:lang="en">Open the project directory from Game Studio</source>
<target xml:lang="pt">Open the project directory from Game Studio</target>
</trans-unit>
<trans-unit id="tu34" xml:space="preserve">
<source xml:lang="en">You can open the project directory from <g id="1">Project &gt; Show in explorer</g> in Game Studio.</source>
<target xml:lang="pt">You can open the project directory from <g id="1">Project &gt; Show in explorer</g> in Game Studio.</target>
</trans-unit>
<trans-unit id="tu35" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Open project directory from Game Studio<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Open project directory from Game Studio<x id="2"/></target>
</trans-unit>
<trans-unit id="tu36" xml:space="preserve">
<source xml:lang="en">Game settings</source>
<target xml:lang="pt">Game settings</target>
</trans-unit>
<trans-unit id="tu37" xml:space="preserve">
<source xml:lang="en">Godot saves global settings in the <g id="1">Project Settings</g> .</source>
<target xml:lang="pt">Godot saves global settings in the <g id="1">Project Settings</g> .</target>
</trans-unit>
<trans-unit id="tu38" xml:space="preserve">
<source xml:lang="en"><x id="1"/>The location is not known to me<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>The location is not known to me<x id="2"/></target>
</trans-unit>
<trans-unit id="tu39" xml:space="preserve">
<source xml:lang="en">Stride saves global settings in a single asset, the Game Settings asset. You can configure:</source>
<target xml:lang="pt">Stride saves global settings in a single asset, the Game Settings asset. You can configure:</target>
</trans-unit>
<trans-unit id="tu40" xml:space="preserve">
<source xml:lang="en">The default scene</source>
<target xml:lang="pt">The default scene</target>
</trans-unit>
<trans-unit id="tu41" xml:space="preserve">
<source xml:lang="en">Rendering settings</source>
<target xml:lang="pt">Rendering settings</target>
</trans-unit>
<trans-unit id="tu42" xml:space="preserve">
<source xml:lang="en">Editor settings</source>
<target xml:lang="pt">Editor settings</target>
</trans-unit>
<trans-unit id="tu43" xml:space="preserve">
<source xml:lang="en">Texture settings</source>
<target xml:lang="pt">Texture settings</target>
</trans-unit>
<trans-unit id="tu44" xml:space="preserve">
<source xml:lang="en">Physics settings</source>
<target xml:lang="pt">Physics settings</target>
</trans-unit>
<trans-unit id="tu45" xml:space="preserve">
<source xml:lang="en">Overrides</source>
<target xml:lang="pt">Overrides</target>
</trans-unit>
<trans-unit id="tu46" xml:space="preserve">
<source xml:lang="en">To use the Game Settings asset, in the <g id="1">Asset View</g>, select <g id="2">GameSettings</g> and view its properties in the <g id="3">Property Grid</g>.</source>
<target xml:lang="pt">To use the Game Settings asset, in the <g id="1">Asset View</g>, select <g id="2">GameSettings</g> and view its properties in the <g id="3">Property Grid</g>.</target>
</trans-unit>
<trans-unit id="tu47" xml:space="preserve">
<source xml:lang="en">Scenes</source>
<target xml:lang="pt">Scenes</target>
</trans-unit>
<trans-unit id="tu48" xml:space="preserve">
<source xml:lang="en">Set the default scene
You can have multiple scenes in your project. Stride loads the default scene at runtime.</source>
<target xml:lang="pt">Set the default scene
You can have multiple scenes in your project. Stride loads the default scene at runtime.</target>
</trans-unit>
<trans-unit id="tu49" xml:space="preserve">
<source xml:lang="en">To set the default scene:</source>
<target xml:lang="pt">To set the default scene:</target>
</trans-unit>
<trans-unit id="tu50" xml:space="preserve">
<source xml:lang="en">Entities vs Nodes</source>
<target xml:lang="pt">Entities vs Nodes</target>
</trans-unit>
<trans-unit id="tu51" xml:space="preserve">
<source xml:lang="en">Directions</source>
<target xml:lang="pt">Directions</target>
</trans-unit>
<trans-unit id="tu52" xml:space="preserve">
<source xml:lang="en">Assets</source>
<target xml:lang="pt">Assets</target>
</trans-unit>
<trans-unit id="tu53" xml:space="preserve">
<source xml:lang="en">Resources</source>
<target xml:lang="pt">Resources</target>
</trans-unit>
<trans-unit id="tu54" xml:space="preserve">
<source xml:lang="en">Stride doesn't have Resources like Godot has. In Stride you can add Folders to your Scene and add there Entities with your Data. Another approach would be to save your former Resources in a separate Prefab and load it into the scenes that need the Data.</source>
<target xml:lang="pt">Stride doesn't have Resources like Godot has. In Stride you can add Folders to your Scene and add there Entities with your Data. Another approach would be to save your former Resources in a separate Prefab and load it into the scenes that need the Data.</target>
</trans-unit>
<trans-unit id="tu55" xml:space="preserve">
<source xml:lang="en">Supported File Formats</source>
<target xml:lang="pt">Supported File Formats</target>
</trans-unit>
<trans-unit id="tu56" xml:space="preserve">
<source xml:lang="en">Like Godot, Stride supports file formats including:</source>
<target xml:lang="pt">Like Godot, Stride supports file formats including:</target>
</trans-unit>
<trans-unit id="tu57" xml:space="preserve">
<source xml:lang="en">Asset type</source>
<target xml:lang="pt">Asset type</target>
</trans-unit>
<trans-unit id="tu58" xml:space="preserve">
<source xml:lang="en">Supported formats</source>
<target xml:lang="pt">Supported formats</target>
</trans-unit>
<trans-unit id="tu59" xml:space="preserve">
<source xml:lang="en">Models, animations, skeletons</source>
<target xml:lang="pt">Models, animations, skeletons</target>
</trans-unit>
<trans-unit id="tu60" xml:space="preserve">
<source xml:lang="en">.dae, .3ds, obj, .blend, .x, .md2, .md3, .dxf, .fbx</source>
<target xml:lang="pt">.dae, .3ds, obj, .blend, .x, .md2, .md3, .dxf, .fbx</target>
</trans-unit>
<trans-unit id="tu61" xml:space="preserve">
<source xml:lang="en">Sprites, textures, skyboxes</source>
<target xml:lang="pt">Sprites, textures, skyboxes</target>
</trans-unit>
<trans-unit id="tu62" xml:space="preserve">
<source xml:lang="en">.dds, .jpg, .jpeg, .png, .gif, .bmp, .tga, .psd, .tif, .tiff</source>
<target xml:lang="pt">.dds, .jpg, .jpeg, .png, .gif, .bmp, .tga, .psd, .tif, .tiff</target>
</trans-unit>
<trans-unit id="tu63" xml:space="preserve">
<source xml:lang="en">Audio</source>
<target xml:lang="pt">Audio</target>
</trans-unit>
<trans-unit id="tu64" xml:space="preserve">
<source xml:lang="en">.wav, .mp3, .ogg, .aac, .aiff, .flac, .m4a, .wma, .mpc</source>
<target xml:lang="pt">.wav, .mp3, .ogg, .aac, .aiff, .flac, .m4a, .wma, .mpc</target>
</trans-unit>
<trans-unit id="tu65" xml:space="preserve">
<source xml:lang="en">Fonts</source>
<target xml:lang="pt">Fonts</target>
</trans-unit>
<trans-unit id="tu66" xml:space="preserve">
<source xml:lang="en">.ttf, .otf</source>
<target xml:lang="pt">.ttf, .otf</target>
</trans-unit>
<trans-unit id="tu67" xml:space="preserve">
<source xml:lang="en">Video</source>
<target xml:lang="pt">Video</target>
</trans-unit>
<trans-unit id="tu68" xml:space="preserve">
<source xml:lang="en">.mp4</source>
<target xml:lang="pt">.mp4</target>
</trans-unit>
<trans-unit id="tu69" xml:space="preserve">
<source xml:lang="en">For more information about assets, see <g id="1">Assets</g>.</source>
<target xml:lang="pt">For more information about assets, see <g id="1">Assets</g>.</target>
</trans-unit>
<trans-unit id="tu70" xml:space="preserve">
<source xml:lang="en">Prefab Inheritance</source>
<target xml:lang="pt">Prefab Inheritance</target>
</trans-unit>
<trans-unit id="tu71" xml:space="preserve">
<source xml:lang="en">The equivalent of Godot's inherited Scene would be ArcheTypes. Archetypes are master assets that control the properties of assets you derive from them. Derived assets are useful when you want to create a "remixed" version of an asset. This is similar to prefabs.</source>
<target xml:lang="pt">The equivalent of Godot's inherited Scene would be ArcheTypes. Archetypes are master assets that control the properties of assets you derive from them. Derived assets are useful when you want to create a "remixed" version of an asset. This is similar to prefabs.</target>
</trans-unit>
<trans-unit id="tu72" xml:space="preserve">
<source xml:lang="en">For example, imagine we have three sphere entities that share a material asset named Metal. Now imagine we want to change the color of only one sphere, but keep its other properties the same. We could duplicate the material asset, change its color, and then apply the new asset to only one sphere. But if we later want to change a different property across all the spheres, we have to modify both assets. This is time-consuming and leaves room for mistakes.</source>
<target xml:lang="pt">For example, imagine we have three sphere entities that share a material asset named Metal. Now imagine we want to change the color of only one sphere, but keep its other properties the same. We could duplicate the material asset, change its color, and then apply the new asset to only one sphere. But if we later want to change a different property across all the spheres, we have to modify both assets. This is time-consuming and leaves room for mistakes.</target>
</trans-unit>
<trans-unit id="tu73" xml:space="preserve">
<source xml:lang="en">The better approach is to derive a new asset from the archetype. The derived asset inherits properties from the archetype and lets you override individual properties where you need them. For example, we can derive the sphere's material asset and override its color. Then, if we change the gloss of the archetype, the gloss of all three spheres changes.</source>
<target xml:lang="pt">The better approach is to derive a new asset from the archetype. The derived asset inherits properties from the archetype and lets you override individual properties where you need them. For example, we can derive the sphere's material asset and override its color. Then, if we change the gloss of the archetype, the gloss of all three spheres changes.</target>
</trans-unit>
<trans-unit id="tu74" xml:space="preserve">
<source xml:lang="en">Input</source>
<target xml:lang="pt">Input</target>
</trans-unit>
<trans-unit id="tu75" xml:space="preserve">
<source xml:lang="en">In Stride you have the Option to get the Input through Key Strokes like in Godot or through Virtual Buttons, which is similar to Godot's Key Mapping</source>
<target xml:lang="pt">In Stride you have the Option to get the Input through Key Strokes like in Godot or through Virtual Buttons, which is similar to Godot's Key Mapping</target>
</trans-unit>
<trans-unit id="tu76" xml:space="preserve">
<source xml:lang="en">public override void Update()
{
    // true for one frame in which the space bar was pressed
    if(Input.IsKeyDown(Keys.Space))
    {
        // Do something.
    }

    // true while this joystick button is down
    if (Input.GameControllers[0].IsButtonDown(0))
    {
        // Do something.
    }

    float Horiz = (Input.IsKeyDown(Keys.Left) ? -1f : 0) + (Input.IsKeyDown(Keys.Right) ? 1f : 0);
    float Vert = (Input.IsKeyDown(Keys.Down) ? -1f : 0) + (Input.IsKeyDown(Keys.Up) ? 1f : 0);
    //Do something else.
}
</source>
<target xml:lang="pt">public override void Update()
{
    // true for one frame in which the space bar was pressed
    if(Input.IsKeyDown(Keys.Space))
    {
        // Do something.
    }

    // true while this joystick button is down
    if (Input.GameControllers[0].IsButtonDown(0))
    {
        // Do something.
    }

    float Horiz = (Input.IsKeyDown(Keys.Left) ? -1f : 0) + (Input.IsKeyDown(Keys.Right) ? 1f : 0);
    float Vert = (Input.IsKeyDown(Keys.Down) ? -1f : 0) + (Input.IsKeyDown(Keys.Up) ? 1f : 0);
    //Do something else.
}
</target>
</trans-unit>
<trans-unit id="tu77" xml:space="preserve">
<source xml:lang="en">Physics</source>
<target xml:lang="pt">Physics</target>
</trans-unit>
<trans-unit id="tu78" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer comprehensive physics engines, but their approach to handling collisions and physics-based interactions differ. Below is a comparison of their features and functionalities.</source>
<target xml:lang="pt">Both Stride and Godot offer comprehensive physics engines, but their approach to handling collisions and physics-based interactions differ. Below is a comparison of their features and functionalities.</target>
</trans-unit>
<trans-unit id="tu79" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu80" xml:space="preserve">
<source xml:lang="en">In Stride, there are three main types of colliders:</source>
<target xml:lang="pt">In Stride, there are three main types of colliders:</target>
</trans-unit>
<trans-unit id="tu81" xml:space="preserve">
<source xml:lang="en"><g id="1">Static Colliders:</g> Fixed in place and do not move, typically used for environment elements like walls or floors.</source>
<target xml:lang="pt"><g id="1">Static Colliders:</g> Fixed in place and do not move, typically used for environment elements like walls or floors.</target>
</trans-unit>
<trans-unit id="tu82" xml:space="preserve">
<source xml:lang="en"><g id="1">Rigidbodies:</g> Dynamic colliders that are subject to physics simulations, such as gravity or force.</source>
<target xml:lang="pt"><g id="1">Rigidbodies:</g> Dynamic colliders that are subject to physics simulations, such as gravity or force.</target>
</trans-unit>
<trans-unit id="tu83" xml:space="preserve">
<source xml:lang="en"><g id="1">Characters:</g> Special colliders designed to work with character controllers.</source>
<target xml:lang="pt"><g id="1">Characters:</g> Special colliders designed to work with character controllers.</target>
</trans-unit>
<trans-unit id="tu84" xml:space="preserve">
<source xml:lang="en">To handle collisions in Stride, you can add methods to a delegate within the <g id="1">Start()</g> method of your script. These methods will be triggered when a collision occurs. For a comprehensive tutorial on collision handling in Stride, you can refer to this <g id="2">YouTube Stride tutorial - Collision triggers</g>.</source>
<target xml:lang="pt">To handle collisions in Stride, you can add methods to a delegate within the <g id="1">Start()</g> method of your script. These methods will be triggered when a collision occurs. For a comprehensive tutorial on collision handling in Stride, you can refer to this <g id="2">YouTube Stride tutorial - Collision triggers</g>.</target>
</trans-unit>
<trans-unit id="tu85" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu86" xml:space="preserve">
<source xml:lang="en">In Godot, you can use a signal-based system to react to collisions. Signals are emitted when specific events occur, such as two objects colliding, and you can connect these signals to custom methods to execute your own logic.</source>
<target xml:lang="pt">In Godot, you can use a signal-based system to react to collisions. Signals are emitted when specific events occur, such as two objects colliding, and you can connect these signals to custom methods to execute your own logic.</target>
</trans-unit>
<trans-unit id="tu87" xml:space="preserve">
<source xml:lang="en">Game Studio Editor</source>
<target xml:lang="pt">Game Studio Editor</target>
</trans-unit>
<trans-unit id="tu88" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer integrated code editors, but their capabilities and recommended usage differ.</source>
<target xml:lang="pt">Both Stride and Godot offer integrated code editors, but their capabilities and recommended usage differ.</target>
</trans-unit>
<trans-unit id="tu89" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu90" xml:space="preserve">
<source xml:lang="en">Stride comes with an integrated C# code editor within Game Studio. Although functional, this editor is not a high-priority feature and may not receive frequent updates. As such, it is generally recommended to use dedicated IDEs for code editing. Some popular choices include:</source>
<target xml:lang="pt">Stride comes with an integrated C# code editor within Game Studio. Although functional, this editor is not a high-priority feature and may not receive frequent updates. As such, it is generally recommended to use dedicated IDEs for code editing. Some popular choices include:</target>
</trans-unit>
<trans-unit id="tu91" xml:space="preserve">
<source xml:lang="en">Visual Studio Code: Free, open-source and highly extensible.</source>
<target xml:lang="pt">Visual Studio Code: Free, open-source and highly extensible.</target>
</trans-unit>
<trans-unit id="tu92" xml:space="preserve">
<source xml:lang="en">Rider: Paid, but offers a robust set of features tailored for .NET development.</source>
<target xml:lang="pt">Rider: Paid, but offers a robust set of features tailored for .NET development.</target>
</trans-unit>
<trans-unit id="tu93" xml:space="preserve">
<source xml:lang="en">Visual Studio Community: Free for small teams and individual developers.</source>
<target xml:lang="pt">Visual Studio Community: Free for small teams and individual developers.</target>
</trans-unit>
<trans-unit id="tu94" xml:space="preserve">
<source xml:lang="en">Visual Studio Professional and Enterprise: Paid versions with additional features and services.</source>
<target xml:lang="pt">Visual Studio Professional and Enterprise: Paid versions with additional features and services.</target>
</trans-unit>
<trans-unit id="tu95" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu96" xml:space="preserve">
<source xml:lang="en">Godot provides a built-in code editor that supports its own scripting language, GDScript, as well as C# and VisualScript. The Godot editor is more tightly integrated with the engine and is generally kept up-to-date with new features.</source>
<target xml:lang="pt">Godot provides a built-in code editor that supports its own scripting language, GDScript, as well as C# and VisualScript. The Godot editor is more tightly integrated with the engine and is generally kept up-to-date with new features.</target>
</trans-unit>
<trans-unit id="tu97" xml:space="preserve">
<source xml:lang="en">In summary, while both Stride and Godot offer integrated code editors, Stride's editor is best considered a supplementary tool rather than a complete IDE. It is advised to use specialized IDEs for more complex development tasks in Stride. Godot's editor, on the other hand, is robust enough for full-scale development if you are using GDScript or C#.</source>
<target xml:lang="pt">In summary, while both Stride and Godot offer integrated code editors, Stride's editor is best considered a supplementary tool rather than a complete IDE. It is advised to use specialized IDEs for more complex development tasks in Stride. Godot's editor, on the other hand, is robust enough for full-scale development if you are using GDScript or C#.</target>
</trans-unit>
<trans-unit id="tu98" xml:space="preserve">
<source xml:lang="en">Scripts</source>
<target xml:lang="pt">Scripts</target>
</trans-unit>
<trans-unit id="tu99" xml:space="preserve">
<source xml:lang="en">Different Approaches to Scripting</source>
<target xml:lang="pt">Different Approaches to Scripting</target>
</trans-unit>
<trans-unit id="tu100" xml:space="preserve">
<source xml:lang="en">In Stride, there are three types of scripts, offering a different paradigm compared to Godot. While Godot requires you to inherit from a specific class to create a node of that type, Stride allows you to extend entities by adding scripts and then searching for specific entities to interact with.</source>
<target xml:lang="pt">In Stride, there are three types of scripts, offering a different paradigm compared to Godot. While Godot requires you to inherit from a specific class to create a node of that type, Stride allows you to extend entities by adding scripts and then searching for specific entities to interact with.</target>
</trans-unit>
<trans-unit id="tu101" xml:space="preserve">
<source xml:lang="en">Extending Entities in Stride</source>
<target xml:lang="pt">Extending Entities in Stride</target>
</trans-unit>
<trans-unit id="tu102" xml:space="preserve">
<source xml:lang="en">For example, instead of inheriting from <g id="1">CharacterBody3D</g> in Godot, in Stride you would attach a <g id="2">CharacterComponent</g> to an entity. Don't forget to also attach a collision shape to make it interactable. In your scripts, you can then search for these components to manipulate them.</source>
<target xml:lang="pt">For example, instead of inheriting from <g id="1">CharacterBody3D</g> in Godot, in Stride you would attach a <g id="2">CharacterComponent</g> to an entity. Don't forget to also attach a collision shape to make it interactable. In your scripts, you can then search for these components to manipulate them.</target>
</trans-unit>
<trans-unit id="tu103" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Stride Example</target>
</trans-unit>
<trans-unit id="tu104" xml:space="preserve">
<source xml:lang="en">// Example of searching for a CharacterComponent in Stride
public class MyScript : SyncScript
{
    public override void Update()
    {
        var characterComponent = Entity.Get&lt;CharacterComponent&gt;();

        if (characterComponent != null)
        {
            // Perform actions on characterComponent
        }
    }
}
</source>
<target xml:lang="pt">// Example of searching for a CharacterComponent in Stride
public class MyScript : SyncScript
{
    public override void Update()
    {
        var characterComponent = Entity.Get&lt;CharacterComponent&gt;();

        if (characterComponent != null)
        {
            // Perform actions on characterComponent
        }
    }
}
</target>
</trans-unit>
<trans-unit id="tu105" xml:space="preserve">
<source xml:lang="en">Delegation Over Inheritance</source>
<target xml:lang="pt">Delegation Over Inheritance</target>
</trans-unit>
<trans-unit id="tu106" xml:space="preserve">
<source xml:lang="en">This approach in Stride embodies the principle of "Delegation over Inheritance", providing you with greater flexibility when designing your game's architecture.</source>
<target xml:lang="pt">This approach in Stride embodies the principle of "Delegation over Inheritance", providing you with greater flexibility when designing your game's architecture.</target>
</trans-unit>
<trans-unit id="tu107" xml:space="preserve">
<source xml:lang="en">StartupScript</source>
<target xml:lang="pt">StartupScript</target>
</trans-unit>
<trans-unit id="tu108" xml:space="preserve">
<source xml:lang="en"><g id="1">StartupScript</g> in Stride has a <g id="2">Start</g> method, which is equivalent to Godot's <g id="3">_Ready</g> method. A <g id="4">StartupScript</g> primarily focuses on initialization tasks and doesn't offer much functionality beyond that.</source>
<target xml:lang="pt"><g id="1">StartupScript</g> in Stride has a <g id="2">Start</g> method, which is equivalent to Godot's <g id="3">_Ready</g> method. A <g id="4">StartupScript</g> primarily focuses on initialization tasks and doesn't offer much functionality beyond that.</target>
</trans-unit>
<trans-unit id="tu109" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Stride Example</target>
</trans-unit>
<trans-unit id="tu110" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : StartupScript
{
    // Public member fields and properties that will be visible in Game Studio
    public override void Start()
    {
        // Initialization code for the script
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}
</source>
<target xml:lang="pt">public class BasicMethods : StartupScript
{
    // Public member fields and properties that will be visible in Game Studio
    public override void Start()
    {
        // Initialization code for the script
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}
</target>
</trans-unit>
<trans-unit id="tu111" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Godot Example</target>
</trans-unit>
<trans-unit id="tu112" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    // This method is equivalent to Stride's Start in StartupScript
    public override void _Ready()
    {
        // Initialization code for the script
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel,
    // but you could use _ExitTree for cleanup
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</source>
<target xml:lang="pt">public class BasicMethods : Node
{
    // This method is equivalent to Stride's Start in StartupScript
    public override void _Ready()
    {
        // Initialization code for the script
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel,
    // but you could use _ExitTree for cleanup
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</target>
</trans-unit>
<trans-unit id="tu113" xml:space="preserve">
<source xml:lang="en">SyncScript</source>
<target xml:lang="pt">SyncScript</target>
</trans-unit>
<trans-unit id="tu114" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer methods that are repeatedly called for game updates. In Stride, this method is called <g id="1">Update()</g> and is part of the <g id="2">SyncScript</g> class. In Godot, the equivalent is <g id="3">_Process(double delta)</g>.</source>
<target xml:lang="pt">Both Stride and Godot offer methods that are repeatedly called for game updates. In Stride, this method is called <g id="1">Update()</g> and is part of the <g id="2">SyncScript</g> class. In Godot, the equivalent is <g id="3">_Process(double delta)</g>.</target>
</trans-unit>
<trans-unit id="tu115" xml:space="preserve">
<source xml:lang="en"><g id="1">Key Differences</g></source>
<target xml:lang="pt"><g id="1">Key Differences</g></target>
</trans-unit>
<trans-unit id="tu116" xml:space="preserve">
<source xml:lang="en"><g id="1">Delta Time:</g> Stride's <g id="2">Update()</g> does not include a delta time parameter. In contrast, Godot provides the time since the last frame as an argument (delta) in <g id="3">_Process(double delta)</g>.</source>
<target xml:lang="pt"><g id="1">Delta Time:</g> Stride's <g id="2">Update()</g> does not include a delta time parameter. In contrast, Godot provides the time since the last frame as an argument (delta) in <g id="3">_Process(double delta)</g>.</target>
</trans-unit>
<trans-unit id="tu117" xml:space="preserve">
<source xml:lang="en"><g id="1">Access to Delta Time:</g> In Stride, you can still access the delta time through the Game property, <g id="2">using Game.UpdateTime.Elapsed.TotalSeconds</g>.</source>
<target xml:lang="pt"><g id="1">Access to Delta Time:</g> In Stride, you can still access the delta time through the Game property, <g id="2">using Game.UpdateTime.Elapsed.TotalSeconds</g>.</target>
</trans-unit>
<trans-unit id="tu118" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Stride Example</target>
</trans-unit>
<trans-unit id="tu119" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : SyncScript
{
    public override void Start() { }
    public override void Cancel() { }        
    public override void Update()
    {
        // Access delta time in Stride
        double deltaTime = Game.UpdateTime.Elapsed.TotalSeconds;

        // Perform actions based on deltaTime
    }
}
</source>
<target xml:lang="pt">public class BasicMethods : SyncScript
{
    public override void Start() { }
    public override void Cancel() { }        
    public override void Update()
    {
        // Access delta time in Stride
        double deltaTime = Game.UpdateTime.Elapsed.TotalSeconds;

        // Perform actions based on deltaTime
    }
}
</target>
</trans-unit>
<trans-unit id="tu120" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Godot Example</target>
</trans-unit>
<trans-unit id="tu121" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    public override void _Ready() { }
    public override void _ExitTree() { }        
    public override void _Process(double delta)
    {
        // Perform actions based on delta
    }
}

</source>
<target xml:lang="pt">public class BasicMethods : Node
{
    public override void _Ready() { }
    public override void _ExitTree() { }        
    public override void _Process(double delta)
    {
        // Perform actions based on delta
    }
}

</target>
</trans-unit>
<trans-unit id="tu122" xml:space="preserve">
<source xml:lang="en">AsyncScripts</source>
<target xml:lang="pt">AsyncScripts</target>
</trans-unit>
<trans-unit id="tu123" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot provide ways to run code asynchronously, but they use different approaches.</source>
<target xml:lang="pt">Both Stride and Godot provide ways to run code asynchronously, but they use different approaches.</target>
</trans-unit>
<trans-unit id="tu124" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Stride Example</target>
</trans-unit>
<trans-unit id="tu125" xml:space="preserve">
<source xml:lang="en">Stride offers a specialized <g id="1">AsyncScript</g> class that allows you to execute code asynchronously using C#'s <g id="2">async</g>/<g id="3">await</g> syntax. The <g id="4">Execute()</g> method can be awaited, allowing your code to run without blocking the main game loop.</source>
<target xml:lang="pt">Stride offers a specialized <g id="1">AsyncScript</g> class that allows you to execute code asynchronously using C#'s <g id="2">async</g>/<g id="3">await</g> syntax. The <g id="4">Execute()</g> method can be awaited, allowing your code to run without blocking the main game loop.</target>
</trans-unit>
<trans-unit id="tu126" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : AsyncScript
{
    // Public member fields and properties will be visible in Game Studio
    public override async Task Execute()
    {
        // The initialization code should come here, if necessary

        // Loop until the game ends (optional depending on the script)
        while (Game.IsRunning)
        {
            await MyEvent;

            // Do some stuff

            // Wait for the next frame (optional depending on the script)
            await Script.NextFrame();
        }
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}

</source>
<target xml:lang="pt">public class BasicMethods : AsyncScript
{
    // Public member fields and properties will be visible in Game Studio
    public override async Task Execute()
    {
        // The initialization code should come here, if necessary

        // Loop until the game ends (optional depending on the script)
        while (Game.IsRunning)
        {
            await MyEvent;

            // Do some stuff

            // Wait for the next frame (optional depending on the script)
            await Script.NextFrame();
        }
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}

</target>
</trans-unit>
<trans-unit id="tu127" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Godot Example</target>
</trans-unit>
<trans-unit id="tu128" xml:space="preserve">
<source xml:lang="en">Godot doesn't offer a dedicated <g id="1">AsyncScript</g> class like Stride. However, you can still write asynchronous code in C# using the standard <g id="2">async</g>/<g id="3">await</g> syntax.</source>
<target xml:lang="pt">Godot doesn't offer a dedicated <g id="1">AsyncScript</g> class like Stride. However, you can still write asynchronous code in C# using the standard <g id="2">async</g>/<g id="3">await</g> syntax.</target>
</trans-unit>
<trans-unit id="tu129" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    public async override void _Ready()
    {
        await ToSignal(GetTree().CreateTimer(1.0f), "timeout");
        // Execute code after 1-second timer elapses
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel method
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</source>
<target xml:lang="pt">public class BasicMethods : Node
{
    public async override void _Ready()
    {
        await ToSignal(GetTree().CreateTimer(1.0f), "timeout");
        // Execute code after 1-second timer elapses
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel method
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</target>
</trans-unit>
<trans-unit id="tu130" xml:space="preserve">
<source xml:lang="en">In summary, both Stride and Godot offer mechanisms for running code asynchronously, but they achieve this in different ways. Stride provides a built-in <g id="1">AsyncScript</g> class, whereas Godot allows for asynchronous code through standard C# mechanisms.</source>
<target xml:lang="pt">In summary, both Stride and Godot offer mechanisms for running code asynchronously, but they achieve this in different ways. Stride provides a built-in <g id="1">AsyncScript</g> class, whereas Godot allows for asynchronous code through standard C# mechanisms.</target>
</trans-unit>
<trans-unit id="tu131" xml:space="preserve">
<source xml:lang="en">Script components</source>
<target xml:lang="pt">Script components</target>
</trans-unit>
<trans-unit id="tu132" xml:space="preserve">
<source xml:lang="en">In both Stride and Godot, scripts are used to define behavior and logic for game entities. However, the way you attach and manage these scripts differs between the two engines.</source>
<target xml:lang="pt">In both Stride and Godot, scripts are used to define behavior and logic for game entities. However, the way you attach and manage these scripts differs between the two engines.</target>
</trans-unit>
<trans-unit id="tu133" xml:space="preserve">
<source xml:lang="en">Create a script</source>
<target xml:lang="pt">Create a script</target>
</trans-unit>
<trans-unit id="tu134" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu135" xml:space="preserve">
<source xml:lang="en">To create a script, click <g id="1">Add asset</g> button and select <g id="2">Scripts</g>.</source>
<target xml:lang="pt">To create a script, click <g id="1">Add asset</g> button and select <g id="2">Scripts</g>.</target>
</trans-unit>
<trans-unit id="tu136" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Create script in Stride<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Create script in Stride<x id="2"/></target>
</trans-unit>
<trans-unit id="tu137" xml:space="preserve">
<source xml:lang="en">Stride has a <g id="1">SyncScript</g> class that comes with methods such as:</source>
<target xml:lang="pt">Stride has a <g id="1">SyncScript</g> class that comes with methods such as:</target>
</trans-unit>
<trans-unit id="tu138" xml:space="preserve">
<source xml:lang="en"><g id="1">Start()</g> is called when the script is loaded.</source>
<target xml:lang="pt"><g id="1">Start()</g> is called when the script is loaded.</target>
</trans-unit>
<trans-unit id="tu139" xml:space="preserve">
<source xml:lang="en"><g id="1">Update()</g> is called every frame.</source>
<target xml:lang="pt"><g id="1">Update()</g> is called every frame.</target>
</trans-unit>
<trans-unit id="tu140" xml:space="preserve">
<source xml:lang="en">If you need asynchronous or startup-specific logic, you can use:</source>
<target xml:lang="pt">If you need asynchronous or startup-specific logic, you can use:</target>
</trans-unit>
<trans-unit id="tu141" xml:space="preserve">
<source xml:lang="en"><g id="1">StartupScript</g>: this script has a single <g id="2">Start()</g> method. It initializes the scene and its content at startup.</source>
<target xml:lang="pt"><g id="1">StartupScript</g>: this script has a single <g id="2">Start()</g> method. It initializes the scene and its content at startup.</target>
</trans-unit>
<trans-unit id="tu142" xml:space="preserve">
<source xml:lang="en"><g id="1">AsyncScript</g>: an asynchronous script with a single method <g id="2">Execute()</g> and you can use <g id="3">async</g>/<g id="4">await</g> inside that method. Asynchronous scripts aren't loaded one by one like synchronous scripts. Instead, they're all loaded in parallel.</source>
<target xml:lang="pt"><g id="1">AsyncScript</g>: an asynchronous script with a single method <g id="2">Execute()</g> and you can use <g id="3">async</g>/<g id="4">await</g> inside that method. Asynchronous scripts aren't loaded one by one like synchronous scripts. Instead, they're all loaded in parallel.</target>
</trans-unit>
<trans-unit id="tu143" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu144" xml:space="preserve">
<source xml:lang="en">In Godot, you can either create a script from the editor or attach an existing script to a node via the Inspector.</source>
<target xml:lang="pt">In Godot, you can either create a script from the editor or attach an existing script to a node via the Inspector.</target>
</trans-unit>
<trans-unit id="tu145" xml:space="preserve">
<source xml:lang="en">In Godot, you use methods like <g id="1">_Ready()</g> for initialization and <g id="2">_Process(delta)</g> for frame-by-frame updates. Godot also supports the <g id="3">async</g>/<g id="4">await</g> syntax in C#.</source>
<target xml:lang="pt">In Godot, you use methods like <g id="1">_Ready()</g> for initialization and <g id="2">_Process(delta)</g> for frame-by-frame updates. Godot also supports the <g id="3">async</g>/<g id="4">await</g> syntax in C#.</target>
</trans-unit>
<trans-unit id="tu146" xml:space="preserve">
<source xml:lang="en">Reload assemblies</source>
<target xml:lang="pt">Reload assemblies</target>
</trans-unit>
<trans-unit id="tu147" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu148" xml:space="preserve">
<source xml:lang="en">After creating or editing a script, you must manually reload the assemblies by clicking <g id="1">Reload assemblies</g> in the Game Studio toolbar.</source>
<target xml:lang="pt">After creating or editing a script, you must manually reload the assemblies by clicking <g id="1">Reload assemblies</g> in the Game Studio toolbar.</target>
</trans-unit>
<trans-unit id="tu149" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Reload assemblies<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Reload assemblies<x id="2"/></target>
</trans-unit>
<trans-unit id="tu150" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu151" xml:space="preserve">
<source xml:lang="en">Godot automatically reloads scripts when they are saved, no manual reload is required.</source>
<target xml:lang="pt">Godot automatically reloads scripts when they are saved, no manual reload is required.</target>
</trans-unit>
<trans-unit id="tu152" xml:space="preserve">
<source xml:lang="en">Add scripts to entities</source>
<target xml:lang="pt">Add scripts to entities</target>
</trans-unit>
<trans-unit id="tu153" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu154" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Entity Tree</g> (on the left by default), or in the scene, select the entity you want to add the script to.</source>
<target xml:lang="pt">In the <g id="1">Entity Tree</g> (on the left by default), or in the scene, select the entity you want to add the script to.</target>
</trans-unit>
<trans-unit id="tu155" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Select an entity<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Select an entity<x id="2"/></target>
</trans-unit>
<trans-unit id="tu156" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Property Grid</g> (on the right by default), click <g id="2">Add component</g> and select the script you want to add.</source>
<target xml:lang="pt">In the <g id="1">Property Grid</g> (on the right by default), click <g id="2">Add component</g> and select the script you want to add.</target>
</trans-unit>
<trans-unit id="tu157" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Add script component<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Add script component<x id="2"/></target>
</trans-unit>
<trans-unit id="tu158" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu159" xml:space="preserve">
<source xml:lang="en">Select the node in the <g id="1">Scene Tree</g>.</source>
<target xml:lang="pt">Select the node in the <g id="1">Scene Tree</g>.</target>
</trans-unit>
<trans-unit id="tu160" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Inspector</g>, click the <g id="2">Attach Script</g> button or attach an existing script.</source>
<target xml:lang="pt">In the <g id="1">Inspector</g>, click the <g id="2">Attach Script</g> button or attach an existing script.</target>
</trans-unit>
<trans-unit id="tu161" xml:space="preserve">
<source xml:lang="en">In Stride, scripts are listed alphabetically along with other components. In Godot, scripts are attached directly to nodes and appear as sub-resources in the <g id="1">Inspector</g>.</source>
<target xml:lang="pt">In Stride, scripts are listed alphabetically along with other components. In Godot, scripts are attached directly to nodes and appear as sub-resources in the <g id="1">Inspector</g>.</target>
</trans-unit>
<trans-unit id="tu162" xml:space="preserve">
<source xml:lang="en">For more information about adding scripts in Stride, see <g id="1">Use a script</g>.</source>
<target xml:lang="pt">For more information about adding scripts in Stride, see <g id="1">Use a script</g>.</target>
</trans-unit>
<trans-unit id="tu163" xml:space="preserve">
<source xml:lang="en">Instantiate Prefabs</source>
<target xml:lang="pt">Instantiate Prefabs</target>
</trans-unit>
<trans-unit id="tu164" xml:space="preserve">
<source xml:lang="en">In Stride, you can instantiate entities using prefabs like so:</source>
<target xml:lang="pt">In Stride, you can instantiate entities using prefabs like so:</target>
</trans-unit>
<trans-unit id="tu165" xml:space="preserve">
<source xml:lang="en">// Public member fields and properties displayed in the Game Studio Property Grid
public Prefab CarPrefab;
public Vector3 SpawnPosition;
public Quaternion SpawnRotation;

public override void Start()
{
    // Initialization of the script
    List&lt;Entity&gt; carEntities = CarPrefab.Instantiate();
    
    // Add the instantiated entities to the root scene
    SceneSystem.SceneInstance.RootScene.Entities.AddRange(carEntities);
    
    // Set the position and rotation for the first entity in the list
    carEntities[0].Transform.Position = SpawnPosition;
    carEntities[0].Transform.Rotation = SpawnRotation;
    
    // Optionally, you can set a name for the entity
    carEntities[0].Name = "MyNewEntity";
}
</source>
<target xml:lang="pt">// Public member fields and properties displayed in the Game Studio Property Grid
public Prefab CarPrefab;
public Vector3 SpawnPosition;
public Quaternion SpawnRotation;

public override void Start()
{
    // Initialization of the script
    List&lt;Entity&gt; carEntities = CarPrefab.Instantiate();
    
    // Add the instantiated entities to the root scene
    SceneSystem.SceneInstance.RootScene.Entities.AddRange(carEntities);
    
    // Set the position and rotation for the first entity in the list
    carEntities[0].Transform.Position = SpawnPosition;
    carEntities[0].Transform.Rotation = SpawnRotation;
    
    // Optionally, you can set a name for the entity
    carEntities[0].Name = "MyNewEntity";
}
</target>
</trans-unit>
<trans-unit id="tu166" xml:space="preserve">
<source xml:lang="en">Serialization</source>
<target xml:lang="pt">Serialization</target>
</trans-unit>
<trans-unit id="tu167" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Godot</target>
</trans-unit>
<trans-unit id="tu168" xml:space="preserve">
<source xml:lang="en">In Godot, you need to inherit from an engine class for it to be visible in the editor. Additionally, only types known to the Godot engine can be exported.</source>
<target xml:lang="pt">In Godot, you need to inherit from an engine class for it to be visible in the editor. Additionally, only types known to the Godot engine can be exported.</target>
</trans-unit>
<trans-unit id="tu169" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu170" xml:space="preserve">
<source xml:lang="en">Stride takes a different approach, aiming for closer integration with C#.</source>
<target xml:lang="pt">Stride takes a different approach, aiming for closer integration with C#.</target>
</trans-unit>
<trans-unit id="tu171" xml:space="preserve">
<source xml:lang="en">Data Contract Attribute</source>
<target xml:lang="pt">Data Contract Attribute</target>
</trans-unit>
<trans-unit id="tu172" xml:space="preserve">
<source xml:lang="en">To make your class serializable within Game Studio, add the <g id="1">[DataContract]</g> attribute to your class. By default, all public members will be serialized.</source>
<target xml:lang="pt">To make your class serializable within Game Studio, add the <g id="1">[DataContract]</g> attribute to your class. By default, all public members will be serialized.</target>
</trans-unit>
<trans-unit id="tu173" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[DataContract]
public class MyClass
{
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu174" xml:space="preserve">
<source xml:lang="en">Data Member Attribute</source>
<target xml:lang="pt">Data Member Attribute</target>
</trans-unit>
<trans-unit id="tu175" xml:space="preserve">
<source xml:lang="en">If you want to be explicit about what gets serialized, you can use the <g id="1">[DataMember]</g> attribute. This is similar to Godot's <g id="2">[Export]</g> attribute.</source>
<target xml:lang="pt">If you want to be explicit about what gets serialized, you can use the <g id="1">[DataMember]</g> attribute. This is similar to Godot's <g id="2">[Export]</g> attribute.</target>
</trans-unit>
<trans-unit id="tu176" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    [DataMember]
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[DataContract]
public class MyClass
{
    [DataMember]
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu177" xml:space="preserve">
<source xml:lang="en">Excluding Members</source>
<target xml:lang="pt">Excluding Members</target>
</trans-unit>
<trans-unit id="tu178" xml:space="preserve">
<source xml:lang="en">To exclude a member from serialization, use the <g id="1">[DataMemberIgnore]</g> attribute.</source>
<target xml:lang="pt">To exclude a member from serialization, use the <g id="1">[DataMemberIgnore]</g> attribute.</target>
</trans-unit>
<trans-unit id="tu179" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    [DataMemberIgnore]
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[DataContract]
public class MyClass
{
    [DataMemberIgnore]
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu180" xml:space="preserve">
<source xml:lang="en">Collections and Dictionaries</source>
<target xml:lang="pt">Collections and Dictionaries</target>
</trans-unit>
<trans-unit id="tu181" xml:space="preserve">
<source xml:lang="en">Stride supports <g id="1">ICollection</g> and <g id="2">IDictionary</g> classes for serialization. Note that only primitives and enums can be used as keys in dictionaries.</source>
<target xml:lang="pt">Stride supports <g id="1">ICollection</g> and <g id="2">IDictionary</g> classes for serialization. Note that only primitives and enums can be used as keys in dictionaries.</target>
</trans-unit>
<trans-unit id="tu182" xml:space="preserve">
<source xml:lang="en">In Godot you have to Export Godot Collections to be visible in the Editor.</source>
<target xml:lang="pt">In Godot you have to Export Godot Collections to be visible in the Editor.</target>
</trans-unit>
<trans-unit id="tu183" xml:space="preserve">
<source xml:lang="en">Nested Serialization</source>
<target xml:lang="pt">Nested Serialization</target>
</trans-unit>
<trans-unit id="tu184" xml:space="preserve">
<source xml:lang="en">You can serialize any class marked with <g id="1">[DataContract]</g> into the editor, including abstract classes or interfaces. The <g id="2">Stride Editor</g> will search for types that match the interfaces or abstract classes, making them eligible for serialization.</source>
<target xml:lang="pt">You can serialize any class marked with <g id="1">[DataContract]</g> into the editor, including abstract classes or interfaces. The <g id="2">Stride Editor</g> will search for types that match the interfaces or abstract classes, making them eligible for serialization.</target>
</trans-unit>
<trans-unit id="tu185" xml:space="preserve">
<source xml:lang="en">Log output</source>
<target xml:lang="pt">Log output</target>
</trans-unit>
<trans-unit id="tu186" xml:space="preserve">
<source xml:lang="en">In Godot you can GD.Print your message. //TODO What does it mean?</source>
<target xml:lang="pt">In Godot you can GD.Print your message. //TODO What does it mean?</target>
</trans-unit>
<trans-unit id="tu187" xml:space="preserve">
<source xml:lang="en">To view the log output, go to the <g id="1">Game Studio</g> toolbar and click on <g id="2">View</g>, then enable the <g id="3">Output</g> option.</source>
<target xml:lang="pt">To view the log output, go to the <g id="1">Game Studio</g> toolbar and click on <g id="2">View</g>, then enable the <g id="3">Output</g> option.</target>
</trans-unit>
<trans-unit id="tu188" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Enable output<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Enable output<x id="2"/></target>
</trans-unit>
<trans-unit id="tu189" xml:space="preserve">
<source xml:lang="en">Once enabled, the <g id="1">Output</g> tab will appear, typically located at the bottom of the <g id="2">Game Studio</g> interface.</source>
<target xml:lang="pt">Once enabled, the <g id="1">Output</g> tab will appear, typically located at the bottom of the <g id="2">Game Studio</g> interface.</target>
</trans-unit>
<trans-unit id="tu190" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Output tab<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Output tab<x id="2"/></target>
</trans-unit>
<trans-unit id="tu191" xml:space="preserve">
<source xml:lang="en">Print debug messages</source>
<target xml:lang="pt">Print debug messages</target>
</trans-unit>
<trans-unit id="tu192" xml:space="preserve">
<source xml:lang="en">To print to the Visual Studio output, use:</source>
<target xml:lang="pt">To print to the Visual Studio output, use:</target>
</trans-unit>
<trans-unit id="tu193" xml:space="preserve">
<source xml:lang="en">System.Diagnostics.Debug.WriteLine("hello");
</source>
<target xml:lang="pt">System.Diagnostics.Debug.WriteLine("hello");
</target>
</trans-unit>
<trans-unit id="tu194" xml:space="preserve">
<source xml:lang="en"><x id="1"/>!Note<x id="2"/>
To print debug messages, you have to run the game from Visual Studio, not Game Studio. There's no way to print to the Game Studio output window.</source>
<target xml:lang="pt"><x id="1"/>!Note<x id="2"/>
To print debug messages, you have to run the game from Visual Studio, not Game Studio. There's no way to print to the Game Studio output window.</target>
</trans-unit>
</body>
</file>
</xliff>