<?xml version="1.0" encoding="UTF-8" standalone="no"?><xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" xmlns:okp="okapi-framework:xliff-extensions" its:version="2.0" version="1.2">
<file datatype="x-text/x-markdown" okp:inputEncoding="UTF-8" original="/D:/repos/rr/source/manual/stride-for-godot-developers/index.md" source-language="en" target-language="pt">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">Stride for Godot developers</source>
<target xml:lang="pt">Stride para desenvolvedores Godot</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">Editor</source>
<target xml:lang="pt">Editor</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Terminology</source>
<target xml:lang="pt">Terminologia</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Scene</source>
<target xml:lang="pt">Cena</target>
</trans-unit>
<trans-unit id="tu7" xml:space="preserve">
<source xml:lang="en">Entity Tree</source>
<target xml:lang="pt">Árvore de Entidade</target>
</trans-unit>
<trans-unit id="tu8" xml:space="preserve">
<source xml:lang="en">Inspector</source>
<target xml:lang="pt">Inspector</target>
</trans-unit>
<trans-unit id="tu9" xml:space="preserve">
<source xml:lang="en">Property Grid</source>
<target xml:lang="pt">Grade de imóveis</target>
</trans-unit>
<trans-unit id="tu10" xml:space="preserve">
<source xml:lang="en">FileSystem</source>
<target xml:lang="pt">Sistema de arquivos</target>
</trans-unit>
<trans-unit id="tu11" xml:space="preserve">
<source xml:lang="en">Solution/Asset View</source>
<target xml:lang="pt">Solução / Visualização de ativos</target>
</trans-unit>
<trans-unit id="tu12" xml:space="preserve">
<source xml:lang="en">Scene view</source>
<target xml:lang="pt">Vista da cena</target>
</trans-unit>
<trans-unit id="tu13" xml:space="preserve">
<source xml:lang="en">Scene Editor</source>
<target xml:lang="pt">Editor de cenas</target>
</trans-unit>
<trans-unit id="tu14" xml:space="preserve">
<source xml:lang="en">Node</source>
<target xml:lang="pt">Node</target>
</trans-unit>
<trans-unit id="tu15" xml:space="preserve">
<source xml:lang="en">Entity</source>
<target xml:lang="pt">Entidade</target>
</trans-unit>
<trans-unit id="tu16" xml:space="preserve">
<source xml:lang="en">Node Script</source>
<target xml:lang="pt">Script de nó</target>
</trans-unit>
<trans-unit id="tu17" xml:space="preserve">
<source xml:lang="en">SyncScript, AsyncScript, StartupScript</source>
<target xml:lang="pt">SyncScript, AsyncScript, StartupScript</target>
</trans-unit>
<trans-unit id="tu18" xml:space="preserve">
<source xml:lang="en">Export</source>
<target xml:lang="pt">Exportação</target>
</trans-unit>
<trans-unit id="tu19" xml:space="preserve">
<source xml:lang="en">Serialize/DataMember</source>
<target xml:lang="pt">Serialize/DataMember</target>
</trans-unit>
<trans-unit id="tu20" xml:space="preserve">
<source xml:lang="en">GlobalClass</source>
<target xml:lang="pt">GlobalClass</target>
</trans-unit>
<trans-unit id="tu21" xml:space="preserve">
<source xml:lang="en">DataContract</source>
<target xml:lang="pt">Contrato de Dados</target>
</trans-unit>
<trans-unit id="tu22" xml:space="preserve">
<source xml:lang="en">Folders and files</source>
<target xml:lang="pt">Pastas e arquivos</target>
</trans-unit>
<trans-unit id="tu23" xml:space="preserve">
<source xml:lang="en"><g id="1">Assets</g></source>
<target xml:lang="pt"><g id="1">Activos</g></target>
</trans-unit>
<trans-unit id="tu24" xml:space="preserve">
<source xml:lang="en">In Godot you can store assets everywhere.</source>
<target xml:lang="pt">Em Godot você pode armazenar ativos em todos os lugares.</target>
</trans-unit>
<trans-unit id="tu25" xml:space="preserve">
<source xml:lang="en">In Stride Assets are in the Assets Folder</source>
<target xml:lang="pt">No Stride Assets estão na pasta de ativos</target>
</trans-unit>
<trans-unit id="tu26" xml:space="preserve">
<source xml:lang="en">Stride and Godot use the Standard C# Solution Structure. Key difference here is that Stride uses the multi Project architecture which leads to the following Projects</source>
<target xml:lang="pt">Stride e Godot usam a Estrutura de Solução C# padrão. A principal diferença aqui é que a Stride usa a arquitetura multiProjeto que leva aos seguintes Projetos</target>
</trans-unit>
<trans-unit id="tu27" xml:space="preserve">
<source xml:lang="en"><g id="1">MyPackage.Game</g> contains your source code.</source>
<target xml:lang="pt"><g id="1">MyPackage.Game</g> contém seu código fonte.</target>
</trans-unit>
<trans-unit id="tu28" xml:space="preserve">
<source xml:lang="en"><g id="1">MyPackage.Platform</g> contains additional code for the platforms your project supports. Game Studio creates folders for each platform (eg <g id="2">MyPackage.Windows</g>, <g id="3">MyPackage.Linux</g>, etc). These folders are usually small, and only contain the entry point of the program.</source>
<target xml:lang="pt"><g id="1">MyPackage.Platform</g> contém código adicional para as plataformas suportadas pelo seu projeto. Game Studio cria pastas para cada plataforma (por exemplo <g id="2">MyPackage. Windows</g>, <g id="3">MyPackage.Linux</g>, etc.). Essas pastas são geralmente pequenas e contêm apenas o ponto de entrada do programa.</target>
</trans-unit>
<trans-unit id="tu29" xml:space="preserve">
<source xml:lang="en">And any other Subprojects. Stride will scan the Subprojects too like the main Project to get DataContract classes and features into the Editor/Game ( it doesn't matter if its in a subproject or not</source>
<target xml:lang="pt">E qualquer outro Subprojeto. Stride irá analisar os Subprojetos também como o projeto principal para obter classes e recursos DataContract no Editor/Game (não importa se o seu em um subprojeto ou não</target>
</trans-unit>
<trans-unit id="tu30" xml:space="preserve">
<source xml:lang="en"><g id="1">Bin:</g> contains the compiled binaries and data. Stride creates the folder when you build the project, with a subdirectory for each platform.</source>
<target xml:lang="pt"><g id="1">Bin:</g> contém os binários e dados compilados. Stride cria a pasta quando você constrói o projeto, com um subdiretório para cada plataforma.</target>
</trans-unit>
<trans-unit id="tu31" xml:space="preserve">
<source xml:lang="en"><g id="1">obj:</g> contains cached files. Game Studio creates this folder when you build your project. To force a complete asset and code rebuild, delete this folder and build the project again.</source>
<target xml:lang="pt"><g id="1">obj:</g> contém arquivos em cache. Game Studio cria esta pasta quando você construir seu projeto. Para forçar um ativo completo e reconstruir código, excluir esta pasta e construir o projeto novamente.</target>
</trans-unit>
<trans-unit id="tu32" xml:space="preserve">
<source xml:lang="en"><g id="1">Resources:</g> is a suggested location for files such as images and audio files used by your assets, do not confuse them with Godot resources, these don't exist in Stride. Stride has in the Scene Folders (these can be used in any way) where you can put classes that would be normally Godot Resources</source>
<target xml:lang="pt"><g id="1">Assets:</g> é um local sugerido para arquivos como imagens e arquivos de áudio usados por seus ativos, não confundi-los com recursos Godot, estes não existem no Stride. Stride tem no Scene Folders (estes podem ser usados de qualquer forma) onde você pode colocar classes que normalmente seriam Godot Assets</target>
</trans-unit>
<trans-unit id="tu33" xml:space="preserve">
<source xml:lang="en">Open the project directory from Game Studio</source>
<target xml:lang="pt">Abra o diretório do projeto do Game Studio</target>
</trans-unit>
<trans-unit id="tu34" xml:space="preserve">
<source xml:lang="en">You can open the project directory from <g id="1">Project &gt; Show in explorer</g> in Game Studio.</source>
<target xml:lang="pt">Você pode abrir o diretório do projeto de <g id="1">Project &gt; Mostrar no explorer</g> no Game Studio.</target>
</trans-unit>
<trans-unit id="tu35" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Open project directory from Game Studio<x id="2"/></source>
<target xml:lang="pt"><x id="1"/> Abra o diretório do projeto do Game Studio<x id="2"/></target>
</trans-unit>
<trans-unit id="tu36" xml:space="preserve">
<source xml:lang="en">Game settings</source>
<target xml:lang="pt">Definições do jogo</target>
</trans-unit>
<trans-unit id="tu37" xml:space="preserve">
<source xml:lang="en">Godot saves global settings in the <g id="1">Project Settings</g> .</source>
<target xml:lang="pt">Godot salva configurações globais no <g id="1">Project Settings</g> .</target>
</trans-unit>
<trans-unit id="tu38" xml:space="preserve">
<source xml:lang="en"><x id="1"/>The location is not known to me<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>A localização não é conhecida por me<x id="2"/></target>
</trans-unit>
<trans-unit id="tu39" xml:space="preserve">
<source xml:lang="en">Stride saves global settings in a single asset, the Game Settings asset. You can configure:</source>
<target xml:lang="pt">Stride salva configurações globais em um único ativo, o ativo Configurações de Jogo. Você pode configurar:</target>
</trans-unit>
<trans-unit id="tu40" xml:space="preserve">
<source xml:lang="en">The default scene</source>
<target xml:lang="pt">A cena padrão</target>
</trans-unit>
<trans-unit id="tu41" xml:space="preserve">
<source xml:lang="en">Rendering settings</source>
<target xml:lang="pt">Configurações de renderização</target>
</trans-unit>
<trans-unit id="tu42" xml:space="preserve">
<source xml:lang="en">Editor settings</source>
<target xml:lang="pt">Definições do editor</target>
</trans-unit>
<trans-unit id="tu43" xml:space="preserve">
<source xml:lang="en">Texture settings</source>
<target xml:lang="pt">Definições de textura</target>
</trans-unit>
<trans-unit id="tu44" xml:space="preserve">
<source xml:lang="en">Physics settings</source>
<target xml:lang="pt">Configurações de física</target>
</trans-unit>
<trans-unit id="tu45" xml:space="preserve">
<source xml:lang="en">Overrides</source>
<target xml:lang="pt">Substituições</target>
</trans-unit>
<trans-unit id="tu46" xml:space="preserve">
<source xml:lang="en">To use the Game Settings asset, in the <g id="1">Asset View</g>, select <g id="2">GameSettings</g> and view its properties in the <g id="3">Property Grid</g>.</source>
<target xml:lang="pt">Para usar o ativo Configurações de Jogo, no <g id="1">Asset View</g>, selecione <g id="2">GameSettings</g> e veja suas propriedades no <g id="3">Property Grid</g>.</target>
</trans-unit>
<trans-unit id="tu47" xml:space="preserve">
<source xml:lang="en">Scenes</source>
<target xml:lang="pt">Cenas</target>
</trans-unit>
<trans-unit id="tu48" xml:space="preserve">
<source xml:lang="en">Set the default scene
You can have multiple scenes in your project. Stride loads the default scene at runtime.</source>
<target xml:lang="pt">Defina a cena padrão
Você pode ter várias cenas em seu projeto. Stride carrega a cena padrão no tempo de execução.</target>
</trans-unit>
<trans-unit id="tu49" xml:space="preserve">
<source xml:lang="en">To set the default scene:</source>
<target xml:lang="pt">Para definir a cena padrão:</target>
</trans-unit>
<trans-unit id="tu50" xml:space="preserve">
<source xml:lang="en">Entities vs Nodes</source>
<target xml:lang="pt">Entidades vs Nodes</target>
</trans-unit>
<trans-unit id="tu51" xml:space="preserve">
<source xml:lang="en">Directions</source>
<target xml:lang="pt">Instruções</target>
</trans-unit>
<trans-unit id="tu52" xml:space="preserve">
<source xml:lang="en">Assets</source>
<target xml:lang="pt">Activos</target>
</trans-unit>
<trans-unit id="tu53" xml:space="preserve">
<source xml:lang="en">Resources</source>
<target xml:lang="pt">Assets</target>
</trans-unit>
<trans-unit id="tu54" xml:space="preserve">
<source xml:lang="en">Stride doesn't have Resources like Godot has. In Stride you can add Folders to your Scene and add there Entities with your Data. Another approach would be to save your former Resources in a separate Prefab and load it into the scenes that need the Data.</source>
<target xml:lang="pt">O Stride não tem recursos como o Godot. Em Stride você pode adicionar pastas à sua cena e adicionar lá Entidades com seus dados. Outra abordagem seria salvar seus antigos Assets em um Prefab separado e carregá-lo nas cenas que precisam dos Dados.</target>
</trans-unit>
<trans-unit id="tu55" xml:space="preserve">
<source xml:lang="en">Supported File Formats</source>
<target xml:lang="pt">Formatos de arquivo suportados</target>
</trans-unit>
<trans-unit id="tu56" xml:space="preserve">
<source xml:lang="en">Like Godot, Stride supports file formats including:</source>
<target xml:lang="pt">Como Godot, Stride suporta formatos de arquivo, incluindo:</target>
</trans-unit>
<trans-unit id="tu57" xml:space="preserve">
<source xml:lang="en">Asset type</source>
<target xml:lang="pt">Tipo de asset</target>
</trans-unit>
<trans-unit id="tu58" xml:space="preserve">
<source xml:lang="en">Supported formats</source>
<target xml:lang="pt">Formatos suportados</target>
</trans-unit>
<trans-unit id="tu59" xml:space="preserve">
<source xml:lang="en">Models, animations, skeletons</source>
<target xml:lang="pt">Modelos, animações, esqueletos</target>
</trans-unit>
<trans-unit id="tu60" xml:space="preserve">
<source xml:lang="en">.dae, .3ds, obj, .blend, .x, .md2, .md3, .dxf, .fbx</source>
<target xml:lang="pt">.dae, .3ds, obj, .blend, .x, .md2, .md3, .dxf, .fbx</target>
</trans-unit>
<trans-unit id="tu61" xml:space="preserve">
<source xml:lang="en">Sprites, textures, skyboxes</source>
<target xml:lang="pt">Sprites, texturas, caixas de céu</target>
</trans-unit>
<trans-unit id="tu62" xml:space="preserve">
<source xml:lang="en">.dds, .jpg, .jpeg, .png, .gif, .bmp, .tga, .psd, .tif, .tiff</source>
<target xml:lang="pt">.dds, .jpg, .jpeg, .png, .gif, .bmp, .tga, .psd, .tif, .tiff</target>
</trans-unit>
<trans-unit id="tu63" xml:space="preserve">
<source xml:lang="en">Audio</source>
<target xml:lang="pt">Áudio</target>
</trans-unit>
<trans-unit id="tu64" xml:space="preserve">
<source xml:lang="en">.wav, .mp3, .ogg, .aac, .aiff, .flac, .m4a, .wma, .mpc</source>
<target xml:lang="pt">.wav, .mp3, .ogg, .aac, .aiff, .flac, .m4a, .wma, .mpc</target>
</trans-unit>
<trans-unit id="tu65" xml:space="preserve">
<source xml:lang="en">Fonts</source>
<target xml:lang="pt">Fontes</target>
</trans-unit>
<trans-unit id="tu66" xml:space="preserve">
<source xml:lang="en">.ttf, .otf</source>
<target xml:lang="pt">.ttf, .otf</target>
</trans-unit>
<trans-unit id="tu67" xml:space="preserve">
<source xml:lang="en">Video</source>
<target xml:lang="pt">Vídeo</target>
</trans-unit>
<trans-unit id="tu68" xml:space="preserve">
<source xml:lang="en">.mp4</source>
<target xml:lang="pt">.mp4</target>
</trans-unit>
<trans-unit id="tu69" xml:space="preserve">
<source xml:lang="en">For more information about assets, see <g id="1">Assets</g>.</source>
<target xml:lang="pt">Para obter mais informações sobre ativos, consulte <g id="1">Ativos</g>.</target>
</trans-unit>
<trans-unit id="tu70" xml:space="preserve">
<source xml:lang="en">Prefab Inheritance</source>
<target xml:lang="pt">Herança pré-fabricada</target>
</trans-unit>
<trans-unit id="tu71" xml:space="preserve">
<source xml:lang="en">The equivalent of Godot's inherited Scene would be ArcheTypes. Archetypes are master assets that control the properties of assets you derive from them. Derived assets are useful when you want to create a "remixed" version of an asset. This is similar to prefabs.</source>
<target xml:lang="pt">O equivalente à cena herdadada de Godot seria ArcheTypes. Os arquétipos são ativos mestres que controlam as propriedades dos ativos derivados deles. Os ativos derivados são úteis quando você quer criar uma versão "remixada" de um ativo. Isto é semelhante a prefabs.</target>
</trans-unit>
<trans-unit id="tu72" xml:space="preserve">
<source xml:lang="en">For example, imagine we have three sphere entities that share a material asset named Metal. Now imagine we want to change the color of only one sphere, but keep its other properties the same. We could duplicate the material asset, change its color, and then apply the new asset to only one sphere. But if we later want to change a different property across all the spheres, we have to modify both assets. This is time-consuming and leaves room for mistakes.</source>
<target xml:lang="pt">Por exemplo, imagine que temos três entidades de esferas que compartilham um ativo material chamado Metal. Agora imagine que queremos mudar a cor de apenas uma esfera, mas mantenha suas outras propriedades iguais. Podemos duplicar o ativo material, mudar sua cor e, em seguida, aplicar o novo ativo a apenas uma esfera. Mas se mais tarde queremos mudar uma propriedade diferente em todas as esferas, temos que modificar ambos os ativos. Isso é demorado e deixa espaço para erros.</target>
</trans-unit>
<trans-unit id="tu73" xml:space="preserve">
<source xml:lang="en">The better approach is to derive a new asset from the archetype. The derived asset inherits properties from the archetype and lets you override individual properties where you need them. For example, we can derive the sphere's material asset and override its color. Then, if we change the gloss of the archetype, the gloss of all three spheres changes.</source>
<target xml:lang="pt">A melhor abordagem é derivar um novo ativo do arquétipo. O ativo derivado herda propriedades do arquétipo e permite que você substitua propriedades individuais onde você precisa delas. Por exemplo, podemos derivar o ativo material da esfera e substituir sua cor. Então, se mudarmos o brilho do arquétipo, o brilho de todas as três esferas muda.</target>
</trans-unit>
<trans-unit id="tu74" xml:space="preserve">
<source xml:lang="en">Input</source>
<target xml:lang="pt">Entrada</target>
</trans-unit>
<trans-unit id="tu75" xml:space="preserve">
<source xml:lang="en">In Stride you have the Option to get the Input through Key Strokes like in Godot or through Virtual Buttons, which is similar to Godot's Key Mapping</source>
<target xml:lang="pt">Em Stride você tem a opção de obter a entrada através de traços chave como em Godot ou através de botões virtuais, que é semelhante ao mapeamento chave de Godot</target>
</trans-unit>
<trans-unit id="tu76" xml:space="preserve">
<source xml:lang="en">public override void Update()
{
    // true for one frame in which the space bar was pressed
    if(Input.IsKeyDown(Keys.Space))
    {
        // Do something.
    }

    // true while this joystick button is down
    if (Input.GameControllers[0].IsButtonDown(0))
    {
        // Do something.
    }

    float Horiz = (Input.IsKeyDown(Keys.Left) ? -1f : 0) + (Input.IsKeyDown(Keys.Right) ? 1f : 0);
    float Vert = (Input.IsKeyDown(Keys.Down) ? -1f : 0) + (Input.IsKeyDown(Keys.Up) ? 1f : 0);
    //Do something else.
}
</source>
<target xml:lang="pt">atualização()
(
    // verdadeiro para um quadro em que a barra de espaço foi pressionada
    if(Input.IsKeyDown(Keys.Space))))
    (
        // Faz alguma coisa.
    }

    // verdadeiro enquanto este botão de joystick está para baixo
    se (Input.GameControllers[0].IsButtonDown(0))
    (
        // Faz alguma coisa.
    }

    flutuar Horiz = (Input.IsKeyDown (Keys.Left) ? - 1f 0) + (Input.IsKeyDown (Keys.Right)? 1f 0);
    float Vert = (Input.IsKeyDown (Keys.Down) ? - 1f 0) + (Input.IsKeyDown (Keys.Up)? 1f 0);
    //Faz outra coisa.
}
</target>
</trans-unit>
<trans-unit id="tu77" xml:space="preserve">
<source xml:lang="en">Physics</source>
<target xml:lang="pt">Física</target>
</trans-unit>
<trans-unit id="tu78" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer comprehensive physics engines, but their approach to handling collisions and physics-based interactions differ. Below is a comparison of their features and functionalities.</source>
<target xml:lang="pt">Tanto Stride quanto Godot oferecem motores de física abrangentes, mas sua abordagem para lidar com colisões e interações físicas diferem. Abaixo está uma comparação de suas características e funcionalidades.</target>
</trans-unit>
<trans-unit id="tu79" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu80" xml:space="preserve">
<source xml:lang="en">In Stride, there are three main types of colliders:</source>
<target xml:lang="pt">Em Stride, existem três tipos principais de colisões:</target>
</trans-unit>
<trans-unit id="tu81" xml:space="preserve">
<source xml:lang="en"><g id="1">Static Colliders:</g> Fixed in place and do not move, typically used for environment elements like walls or floors.</source>
<target xml:lang="pt"><g id="1"> Colliders estáticos:</g> Fixo no lugar e não se mova, tipicamente usado para elementos de ambiente como paredes ou pisos.</target>
</trans-unit>
<trans-unit id="tu82" xml:space="preserve">
<source xml:lang="en"><g id="1">Rigidbodies:</g> Dynamic colliders that are subject to physics simulations, such as gravity or force.</source>
<target xml:lang="pt"><g id="1">Rigidbodies:</g> Colliders dinâmicos que estão sujeitos a simulações físicas, como gravidade ou força.</target>
</trans-unit>
<trans-unit id="tu83" xml:space="preserve">
<source xml:lang="en"><g id="1">Characters:</g> Special colliders designed to work with character controllers.</source>
<target xml:lang="pt"><g id="1">Characters:</g> Colliders especiais projetados para trabalhar com controladores de caracteres.</target>
</trans-unit>
<trans-unit id="tu84" xml:space="preserve">
<source xml:lang="en">To handle collisions in Stride, you can add methods to a delegate within the <g id="1">Start()</g> method of your script. These methods will be triggered when a collision occurs. For a comprehensive tutorial on collision handling in Stride, you can refer to this <g id="2">YouTube Stride tutorial - Collision triggers</g>.</source>
<target xml:lang="pt">Para lidar com colisões no Stride, você pode adicionar métodos para um delegado dentro do método <g id="1">Start()</g> do seu script. Esses métodos serão acionados quando ocorrer uma colisão. Para um tutorial abrangente sobre manipulação de colisão em Stride, você pode se referir a este tutorial <g id="2">YouTube Stride - Collision triggers</g>.</target>
</trans-unit>
<trans-unit id="tu85" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu86" xml:space="preserve">
<source xml:lang="en">In Godot, you can use a signal-based system to react to collisions. Signals are emitted when specific events occur, such as two objects colliding, and you can connect these signals to custom methods to execute your own logic.</source>
<target xml:lang="pt">Em Godot, você pode usar um sistema baseado em sinal para reagir a colisões. Sinais são emitidos quando eventos específicos ocorrem, como dois objetos colidindo, e você pode conectar esses sinais a métodos personalizados para executar sua própria lógica.</target>
</trans-unit>
<trans-unit id="tu87" xml:space="preserve">
<source xml:lang="en">Game Studio Editor</source>
<target xml:lang="pt">Edição de Estúdio de Jogo</target>
</trans-unit>
<trans-unit id="tu88" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer integrated code editors, but their capabilities and recommended usage differ.</source>
<target xml:lang="pt">Tanto Stride quanto Godot oferecem editores de código integrados, mas suas capacidades e uso recomendado diferem.</target>
</trans-unit>
<trans-unit id="tu89" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu90" xml:space="preserve">
<source xml:lang="en">Stride comes with an integrated C# code editor within Game Studio. Although functional, this editor is not a high-priority feature and may not receive frequent updates. As such, it is generally recommended to use dedicated IDEs for code editing. Some popular choices include:</source>
<target xml:lang="pt">Stride vem com um editor de código C# integrado no Game Studio. Embora funcional, este editor não é um asset de alta prioridade e pode não receber atualizações frequentes. Como tal, é geralmente recomendado usar IDEs dedicados para edição de código. Algumas escolhas populares incluem:</target>
</trans-unit>
<trans-unit id="tu91" xml:space="preserve">
<source xml:lang="en">Visual Studio Code: Free, open-source and highly extensible.</source>
<target xml:lang="pt">Visual Studio Código: Livre, open-source e altamente extensível.</target>
</trans-unit>
<trans-unit id="tu92" xml:space="preserve">
<source xml:lang="en">Rider: Paid, but offers a robust set of features tailored for .NET development.</source>
<target xml:lang="pt">Rider: Pago, mas oferece um conjunto robusto de assets adaptados para . Desenvolvimento de NET.</target>
</trans-unit>
<trans-unit id="tu93" xml:space="preserve">
<source xml:lang="en">Visual Studio Community: Free for small teams and individual developers.</source>
<target xml:lang="pt">Comunidade Visual Studio: Livre para equipes pequenas e desenvolvedores individuais.</target>
</trans-unit>
<trans-unit id="tu94" xml:space="preserve">
<source xml:lang="en">Visual Studio Professional and Enterprise: Paid versions with additional features and services.</source>
<target xml:lang="pt">Visual Studio Professional e Enterprise: Versões pagas com recursos e serviços adicionais.</target>
</trans-unit>
<trans-unit id="tu95" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu96" xml:space="preserve">
<source xml:lang="en">Godot provides a built-in code editor that supports its own scripting language, GDScript, as well as C# and VisualScript. The Godot editor is more tightly integrated with the engine and is generally kept up-to-date with new features.</source>
<target xml:lang="pt">Godot fornece um editor de código integrado que suporta sua própria linguagem de scripting, GDScript, bem como C# e VisualScript. O editor Godot é mais firmemente integrado com o motor e geralmente é mantido up-to-date com novos recursos.</target>
</trans-unit>
<trans-unit id="tu97" xml:space="preserve">
<source xml:lang="en">In summary, while both Stride and Godot offer integrated code editors, Stride's editor is best considered a supplementary tool rather than a complete IDE. It is advised to use specialized IDEs for more complex development tasks in Stride. Godot's editor, on the other hand, is robust enough for full-scale development if you are using GDScript or C#.</source>
<target xml:lang="pt">Em resumo, enquanto Stride e Godot oferecem editores de código integrados, o editor de Stride é melhor considerado uma ferramenta complementar em vez de um IDE completo. Recomenda-se usar IDEs especializados para tarefas de desenvolvimento mais complexas em Stride. O editor de Godot, por outro lado, é robusto o suficiente para o desenvolvimento em larga escala se você estiver usando GDScript ou C#.</target>
</trans-unit>
<trans-unit id="tu98" xml:space="preserve">
<source xml:lang="en">Scripts</source>
<target xml:lang="pt">Scripts</target>
</trans-unit>
<trans-unit id="tu99" xml:space="preserve">
<source xml:lang="en">Different Approaches to Scripting</source>
<target xml:lang="pt">Diferentes abordagens para scripting</target>
</trans-unit>
<trans-unit id="tu100" xml:space="preserve">
<source xml:lang="en">In Stride, there are three types of scripts, offering a different paradigm compared to Godot. While Godot requires you to inherit from a specific class to create a node of that type, Stride allows you to extend entities by adding scripts and then searching for specific entities to interact with.</source>
<target xml:lang="pt">Em Stride, existem três tipos de scripts, oferecendo um paradigma diferente em comparação com Godot. Enquanto Godot exige que você herda de uma classe específica para criar um nó desse tipo, Stride permite que você estender entidades adicionando scripts e, em seguida, procurando entidades específicas para interagir com.</target>
</trans-unit>
<trans-unit id="tu101" xml:space="preserve">
<source xml:lang="en">Extending Entities in Stride</source>
<target xml:lang="pt">Entidades pendentes em Stride</target>
</trans-unit>
<trans-unit id="tu102" xml:space="preserve">
<source xml:lang="en">For example, instead of inheriting from <g id="1">CharacterBody3D</g> in Godot, in Stride you would attach a <g id="2">CharacterComponent</g> to an entity. Don't forget to also attach a collision shape to make it interactable. In your scripts, you can then search for these components to manipulate them.</source>
<target xml:lang="pt">Por exemplo, em vez de herdar de <g id="1">CharacterBody3D</g> em Godot, em Stride você anexaria um <g id="2">CharacterComponent</g> a uma entidade. Não se esqueça de também anexar uma forma de colisão para torná-la interagiável. Em seus scripts, você pode então procurar esses componentes para manipulá-los.</target>
</trans-unit>
<trans-unit id="tu103" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Exemplo de Stride</target>
</trans-unit>
<trans-unit id="tu104" xml:space="preserve">
<source xml:lang="en">// Example of searching for a CharacterComponent in Stride
public class MyScript : SyncScript
{
    public override void Update()
    {
        var characterComponent = Entity.Get&lt;CharacterComponent&gt;();

        if (characterComponent != null)
        {
            // Perform actions on characterComponent
        }
    }
}
</source>
<target xml:lang="pt">// Exemplo de pesquisa para um CharacterComponent em Stride
classe pública MyScript : Sincronização
(
    atualização()
    (
        personagem Componente = Entity.Get&lt;CharacterComponent&gt;();

        if (characterComponent!= null)
        (
            // Executar ações no caracterComponent
        }
    }
}
</target>
</trans-unit>
<trans-unit id="tu105" xml:space="preserve">
<source xml:lang="en">Delegation Over Inheritance</source>
<target xml:lang="pt">Delegação Sobre a Herança</target>
</trans-unit>
<trans-unit id="tu106" xml:space="preserve">
<source xml:lang="en">This approach in Stride embodies the principle of "Delegation over Inheritance", providing you with greater flexibility when designing your game's architecture.</source>
<target xml:lang="pt">Esta abordagem em Stride incorpora o princípio de "Delegação sobre a Herança", proporcionando-lhe maior flexibilidade ao projetar a arquitetura do seu jogo.</target>
</trans-unit>
<trans-unit id="tu107" xml:space="preserve">
<source xml:lang="en">StartupScript</source>
<target xml:lang="pt">StartupScript</target>
</trans-unit>
<trans-unit id="tu108" xml:space="preserve">
<source xml:lang="en"><g id="1">StartupScript</g> in Stride has a <g id="2">Start</g> method, which is equivalent to Godot's <g id="3">_Ready</g> method. A <g id="4">StartupScript</g> primarily focuses on initialization tasks and doesn't offer much functionality beyond that.</source>
<target xml:lang="pt"><g id="1">StartupScript</g> em Stride tem um método <g id="2">Start</g>, que é equivalente ao método <g id="3">_Ready</g>. A <g id="4">StartupScript</g> foca principalmente em tarefas de inicialização e não oferece muita funcionalidade além disso.</target>
</trans-unit>
<trans-unit id="tu109" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Exemplo de Stride</target>
</trans-unit>
<trans-unit id="tu110" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : StartupScript
{
    // Public member fields and properties that will be visible in Game Studio
    public override void Start()
    {
        // Initialization code for the script
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}
</source>
<target xml:lang="pt">classe pública BasicMethods: StartupScript
(
    // Campos e propriedades de membros públicos que serão visíveis no Game Studio
    anula de sobreposição pública Start()
    (
        // Código de inicialização para o script
    }

    sobreposição pública cancel()
    (
        // Código de limpeza para o script
    }     
}
</target>
</trans-unit>
<trans-unit id="tu111" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Exemplo de Godot</target>
</trans-unit>
<trans-unit id="tu112" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    // This method is equivalent to Stride's Start in StartupScript
    public override void _Ready()
    {
        // Initialization code for the script
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel,
    // but you could use _ExitTree for cleanup
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</source>
<target xml:lang="pt">classe pública BasicMethods: Node
(
    // Este método é equivalente a Stride's Start in StartupScript
    sobreposição pública vazio _Ready()
    (
        // Código de inicialização para o script
    }

    // Godot não tem um equivalente direto a Stride's Cancel,
    // mas você poderia usar _ExitTree para limpeza
    anula de sobreposição pública _ExitTree()
    (
        // Código de limpeza para o script
    }
}
</target>
</trans-unit>
<trans-unit id="tu113" xml:space="preserve">
<source xml:lang="en">SyncScript</source>
<target xml:lang="pt">Sincronização</target>
</trans-unit>
<trans-unit id="tu114" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot offer methods that are repeatedly called for game updates. In Stride, this method is called <g id="1">Update()</g> and is part of the <g id="2">SyncScript</g> class. In Godot, the equivalent is <g id="3">_Process(double delta)</g>.</source>
<target xml:lang="pt">Tanto Stride quanto Godot oferecem métodos que são repetidamente chamados para atualizações do jogo. Em Stride, este método é chamado de <g id="1">Update()</g> e faz parte da classe <g id="2">SyncScript</g>. Em Godot, o equivalente é <g id="3">_Process(double delta)</g>.</target>
</trans-unit>
<trans-unit id="tu115" xml:space="preserve">
<source xml:lang="en"><g id="1">Key Differences</g></source>
<target xml:lang="pt"><g id="1">Principais diferenças</g></target>
</trans-unit>
<trans-unit id="tu116" xml:space="preserve">
<source xml:lang="en"><g id="1">Delta Time:</g> Stride's <g id="2">Update()</g> does not include a delta time parameter. In contrast, Godot provides the time since the last frame as an argument (delta) in <g id="3">_Process(double delta)</g>.</source>
<target xml:lang="pt"><g id="1">Delta Tempo:</g> Stride's <g id="2">Update()</g> não inclui um parâmetro de tempo delta. Em contraste, Godot fornece o tempo desde o último quadro como um argumento (delta) em <g id="3">_Process(double delta)</g>.</target>
</trans-unit>
<trans-unit id="tu117" xml:space="preserve">
<source xml:lang="en"><g id="1">Access to Delta Time:</g> In Stride, you can still access the delta time through the Game property, <g id="2">using Game.UpdateTime.Elapsed.TotalSeconds</g>.</source>
<target xml:lang="pt"><g id="1">Acesso ao Tempo Delta:</g> Em Stride, você ainda pode acessar o tempo delta através da propriedade Game, <g id="2">usando Game.UpdateTime.Elapsed.TotalSeconds</g>.</target>
</trans-unit>
<trans-unit id="tu118" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Exemplo de Stride</target>
</trans-unit>
<trans-unit id="tu119" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : SyncScript
{
    public override void Start() { }
    public override void Cancel() { }        
    public override void Update()
    {
        // Access delta time in Stride
        double deltaTime = Game.UpdateTime.Elapsed.TotalSeconds;

        // Perform actions based on deltaTime
    }
}
</source>
<target xml:lang="pt">classe pública BasicMethods: Sincronização
(
    anulado público Start() { }
    público anulado Cancelar() { }        
    atualização()
    (
        // Acesso delta tempo em Stride
        double deltaTime = Game.UpdateTime.Elapsed.TotalSeconds;

        // Realizar ações com base no delta Tempo
    }
}
</target>
</trans-unit>
<trans-unit id="tu120" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Exemplo de Godot</target>
</trans-unit>
<trans-unit id="tu121" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    public override void _Ready() { }
    public override void _ExitTree() { }        
    public override void _Process(double delta)
    {
        // Perform actions based on delta
    }
}

</source>
<target xml:lang="pt">classe pública BasicMethods: Node
(
    anulado público _Ready() { }
    anulado público _ExitTree() { }        
    anula de sobreposição pública _Process(double delta)
    (
        // Realizar ações com base no delta
    }
}

</target>
</trans-unit>
<trans-unit id="tu122" xml:space="preserve">
<source xml:lang="en">AsyncScripts</source>
<target xml:lang="pt">AsyncScripts</target>
</trans-unit>
<trans-unit id="tu123" xml:space="preserve">
<source xml:lang="en">Both Stride and Godot provide ways to run code asynchronously, but they use different approaches.</source>
<target xml:lang="pt">Tanto Stride quanto Godot fornecem maneiras de executar o código assíncrono, mas eles usam diferentes abordagens.</target>
</trans-unit>
<trans-unit id="tu124" xml:space="preserve">
<source xml:lang="en">Stride Example</source>
<target xml:lang="pt">Exemplo de Stride</target>
</trans-unit>
<trans-unit id="tu125" xml:space="preserve">
<source xml:lang="en">Stride offers a specialized <g id="1">AsyncScript</g> class that allows you to execute code asynchronously using C#'s <g id="2">async</g>/<g id="3">await</g> syntax. The <g id="4">Execute()</g> method can be awaited, allowing your code to run without blocking the main game loop.</source>
<target xml:lang="pt">Stride oferece uma classe especializada <g id="1">AsyncScript</g> que permite executar o código assíncrono usando a sintaxe <g id="2">async</g>/<g id="3">await</g>. O método <g id="4">Execute()</g> pode ser aguardado, permitindo que seu código seja executado sem bloquear o loop principal do jogo.</target>
</trans-unit>
<trans-unit id="tu126" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : AsyncScript
{
    // Public member fields and properties will be visible in Game Studio
    public override async Task Execute()
    {
        // The initialization code should come here, if necessary

        // Loop until the game ends (optional depending on the script)
        while (Game.IsRunning)
        {
            await MyEvent;

            // Do some stuff

            // Wait for the next frame (optional depending on the script)
            await Script.NextFrame();
        }
    }

    public override void Cancel()
    {
        // Cleanup code for the script
    }     
}

</source>
<target xml:lang="pt">classe pública BasicMethods: AsyncScript
(
    // Campos e propriedades de membros públicos serão visíveis no Game Studio
    override público async Task Execute()
    (
        // O código de inicialização deve vir aqui, se necessário

        // Loop até o fim do jogo (opcional dependendo do script)
        enquanto (Game.IsRunning)
        (
            aguarde MyEvent;

            // Faz alguma coisa

            // Aguarde o próximo quadro (opcional dependendo do script)
            await Script.NextFrame();
        }
    }

    sobreposição pública cancel()
    (
        // Código de limpeza para o script
    }     
}

</target>
</trans-unit>
<trans-unit id="tu127" xml:space="preserve">
<source xml:lang="en">Godot Example</source>
<target xml:lang="pt">Exemplo de Godot</target>
</trans-unit>
<trans-unit id="tu128" xml:space="preserve">
<source xml:lang="en">Godot doesn't offer a dedicated <g id="1">AsyncScript</g> class like Stride. However, you can still write asynchronous code in C# using the standard <g id="2">async</g>/<g id="3">await</g> syntax.</source>
<target xml:lang="pt">Godot não oferece uma classe dedicada &lt;g id="1"&gt;AsyncScript&lt;/g&gt; como Stride. No entanto, você ainda pode escrever código assíncrono em C# usando o padrão &lt;g id="2"&gt;async&lt;/g&gt;await&lt;/g&gt; sintaxe.&lt;g id="3"&gt;</target>
</trans-unit>
<trans-unit id="tu129" xml:space="preserve">
<source xml:lang="en">public class BasicMethods : Node
{
    public async override void _Ready()
    {
        await ToSignal(GetTree().CreateTimer(1.0f), "timeout");
        // Execute code after 1-second timer elapses
    }

    // Godot doesn't have a direct equivalent to Stride's Cancel method
    public override void _ExitTree()
    {
        // Cleanup code for the script
    }
}
</source>
<target xml:lang="pt">classe pública BasicMethods: Node
(
    público async anulado _Ready()
    (
        esperar ToSignal (GetTree().CreateTimer(1.0f), "timeout");
        // Executar código após 1 segundo timer elapses
    }

    // Godot não tem um equivalente direto ao método Stride's Cancel
    anula de sobreposição pública _ExitTree()
    (
        // Código de limpeza para o script
    }
}
</target>
</trans-unit>
<trans-unit id="tu130" xml:space="preserve">
<source xml:lang="en">In summary, both Stride and Godot offer mechanisms for running code asynchronously, but they achieve this in different ways. Stride provides a built-in <g id="1">AsyncScript</g> class, whereas Godot allows for asynchronous code through standard C# mechanisms.</source>
<target xml:lang="pt">Em resumo, tanto Stride quanto Godot oferecem mecanismos para executar o código assíncrono, mas eles conseguem isso de maneiras diferentes. Stride fornece uma classe <g id="1">AsyncScript</g>, enquanto Godot permite o código assíncrono através de mecanismos C# padrão.</target>
</trans-unit>
<trans-unit id="tu131" xml:space="preserve">
<source xml:lang="en">Script components</source>
<target xml:lang="pt">Componentes de script</target>
</trans-unit>
<trans-unit id="tu132" xml:space="preserve">
<source xml:lang="en">In both Stride and Godot, scripts are used to define behavior and logic for game entities. However, the way you attach and manage these scripts differs between the two engines.</source>
<target xml:lang="pt">Em Stride e Godot, os scripts são usados para definir comportamento e lógica para entidades do jogo. No entanto, a forma como você anexa e gerencia esses scripts difere entre os dois motores.</target>
</trans-unit>
<trans-unit id="tu133" xml:space="preserve">
<source xml:lang="en">Create a script</source>
<target xml:lang="pt">Criar um script</target>
</trans-unit>
<trans-unit id="tu134" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu135" xml:space="preserve">
<source xml:lang="en">To create a script, click <g id="1">Add asset</g> button and select <g id="2">Scripts</g>.</source>
<target xml:lang="pt">Para criar um script, clique em <g id="1"> Adicionar asset</g> e selecione <g id="2">Scripts</g>.</target>
</trans-unit>
<trans-unit id="tu136" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Create script in Stride<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Criar script em Stride<x id="2"/></target>
</trans-unit>
<trans-unit id="tu137" xml:space="preserve">
<source xml:lang="en">Stride has a <g id="1">SyncScript</g> class that comes with methods such as:</source>
<target xml:lang="pt">Stride tem uma classe <g id="1">SyncScript</g> que vem com métodos como:</target>
</trans-unit>
<trans-unit id="tu138" xml:space="preserve">
<source xml:lang="en"><g id="1">Start()</g> is called when the script is loaded.</source>
<target xml:lang="pt"><g id="1">Start()</g> é chamado quando o script é carregado.</target>
</trans-unit>
<trans-unit id="tu139" xml:space="preserve">
<source xml:lang="en"><g id="1">Update()</g> is called every frame.</source>
<target xml:lang="pt"><g id="1">Update()</g> é chamado cada quadro.</target>
</trans-unit>
<trans-unit id="tu140" xml:space="preserve">
<source xml:lang="en">If you need asynchronous or startup-specific logic, you can use:</source>
<target xml:lang="pt">Se você precisar de lógica assíncrona ou específica de inicialização, você pode usar:</target>
</trans-unit>
<trans-unit id="tu141" xml:space="preserve">
<source xml:lang="en"><g id="1">StartupScript</g>: this script has a single <g id="2">Start()</g> method. It initializes the scene and its content at startup.</source>
<target xml:lang="pt"><g id="1">StartupScript</g>: este script tem um único método <g id="2">Start()</g>. Ele inicializa a cena e seu conteúdo na inicialização.</target>
</trans-unit>
<trans-unit id="tu142" xml:space="preserve">
<source xml:lang="en"><g id="1">AsyncScript</g>: an asynchronous script with a single method <g id="2">Execute()</g> and you can use <g id="3">async</g>/<g id="4">await</g> inside that method. Asynchronous scripts aren't loaded one by one like synchronous scripts. Instead, they're all loaded in parallel.</source>
<target xml:lang="pt"><g id="1">AsyncScript</g>: um script assíncrono com um único método <g id="2">Execute()</g> e você pode usar <g id="3">async</g>/&gt;/<g id="4">await</g> dentro desse método. Os scripts assíncronos não são carregados um por um como scripts síncronos. Em vez disso, estão todos carregados em paralelo.</target>
</trans-unit>
<trans-unit id="tu143" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu144" xml:space="preserve">
<source xml:lang="en">In Godot, you can either create a script from the editor or attach an existing script to a node via the Inspector.</source>
<target xml:lang="pt">Em Godot, você pode criar um script do editor ou anexar um script existente a um nó através do Inspector.</target>
</trans-unit>
<trans-unit id="tu145" xml:space="preserve">
<source xml:lang="en">In Godot, you use methods like <g id="1">_Ready()</g> for initialization and <g id="2">_Process(delta)</g> for frame-by-frame updates. Godot also supports the <g id="3">async</g>/<g id="4">await</g> syntax in C#.</source>
<target xml:lang="pt">Em Godot, você usa métodos como <g id="1">_Ready()</g> para inicialização e <g id="2">_Process(delta)</g> para atualizações frame-by-frame. Godot também suporta a sintaxe <g id="3">async</g>/<g id="4">await</g> em C#.</target>
</trans-unit>
<trans-unit id="tu146" xml:space="preserve">
<source xml:lang="en">Reload assemblies</source>
<target xml:lang="pt">Conjuntos de recarga</target>
</trans-unit>
<trans-unit id="tu147" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu148" xml:space="preserve">
<source xml:lang="en">After creating or editing a script, you must manually reload the assemblies by clicking <g id="1">Reload assemblies</g> in the Game Studio toolbar.</source>
<target xml:lang="pt">Depois de criar ou editar um script, você deve recarregar manualmente as assembléias clicando <g id="1">Reload assemblies</g> na barra de ferramentas Game Studio.</target>
</trans-unit>
<trans-unit id="tu149" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Reload assemblies<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Reload assemblies<x id="2"/></target>
</trans-unit>
<trans-unit id="tu150" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu151" xml:space="preserve">
<source xml:lang="en">Godot automatically reloads scripts when they are saved, no manual reload is required.</source>
<target xml:lang="pt">Godot automaticamente recarrega scripts quando eles são salvos, nenhuma recarga manual é necessária.</target>
</trans-unit>
<trans-unit id="tu152" xml:space="preserve">
<source xml:lang="en">Add scripts to entities</source>
<target xml:lang="pt">Adicionar scripts a entidades</target>
</trans-unit>
<trans-unit id="tu153" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu154" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Entity Tree</g> (on the left by default), or in the scene, select the entity you want to add the script to.</source>
<target xml:lang="pt">No <g id="1">Entity Tree</g> (à esquerda por padrão), ou na cena, selecione a entidade a que deseja adicionar o script.</target>
</trans-unit>
<trans-unit id="tu155" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Select an entity<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Selecione uma entidade<x id="2"/></target>
</trans-unit>
<trans-unit id="tu156" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Property Grid</g> (on the right by default), click <g id="2">Add component</g> and select the script you want to add.</source>
<target xml:lang="pt">No <g id="1">Property Grid</g> (à direita por padrão), clique em <g id="2">Add component</g> e selecione o script que deseja adicionar.</target>
</trans-unit>
<trans-unit id="tu157" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Add script component<x id="2"/></source>
<target xml:lang="pt"><x id="1"/> Adicionar componente de script<x id="2"/></target>
</trans-unit>
<trans-unit id="tu158" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu159" xml:space="preserve">
<source xml:lang="en">Select the node in the <g id="1">Scene Tree</g>.</source>
<target xml:lang="pt">Selecione o nó no <g id="1">Scene Tree</g>.</target>
</trans-unit>
<trans-unit id="tu160" xml:space="preserve">
<source xml:lang="en">In the <g id="1">Inspector</g>, click the <g id="2">Attach Script</g> button or attach an existing script.</source>
<target xml:lang="pt">No <g id="1">Inspector</g>, clique no botão <g id="2">Attach Script</g> ou prenda um script existente.</target>
</trans-unit>
<trans-unit id="tu161" xml:space="preserve">
<source xml:lang="en">In Stride, scripts are listed alphabetically along with other components. In Godot, scripts are attached directly to nodes and appear as sub-resources in the <g id="1">Inspector</g>.</source>
<target xml:lang="pt">Em Stride, os scripts são listados alfabeticamente junto com outros componentes. Em Godot, os scripts são anexados diretamente aos nós e aparecem como sub-recursos no <g id="1">Inspector</g>.</target>
</trans-unit>
<trans-unit id="tu162" xml:space="preserve">
<source xml:lang="en">For more information about adding scripts in Stride, see <g id="1">Use a script</g>.</source>
<target xml:lang="pt">Para obter mais informações sobre como adicionar scripts no Stride, consulte <g id="1">Use um script</g>.</target>
</trans-unit>
<trans-unit id="tu163" xml:space="preserve">
<source xml:lang="en">Instantiate Prefabs</source>
<target xml:lang="pt">Pré-fabricados instantâneos</target>
</trans-unit>
<trans-unit id="tu164" xml:space="preserve">
<source xml:lang="en">In Stride, you can instantiate entities using prefabs like so:</source>
<target xml:lang="pt">Em Stride, você pode instanciar entidades usando prefabs como assim:</target>
</trans-unit>
<trans-unit id="tu165" xml:space="preserve">
<source xml:lang="en">// Public member fields and properties displayed in the Game Studio Property Grid
public Prefab CarPrefab;
public Vector3 SpawnPosition;
public Quaternion SpawnRotation;

public override void Start()
{
    // Initialization of the script
    List&lt;Entity&gt; carEntities = CarPrefab.Instantiate();
    
    // Add the instantiated entities to the root scene
    SceneSystem.SceneInstance.RootScene.Entities.AddRange(carEntities);
    
    // Set the position and rotation for the first entity in the list
    carEntities[0].Transform.Position = SpawnPosition;
    carEntities[0].Transform.Rotation = SpawnRotation;
    
    // Optionally, you can set a name for the entity
    carEntities[0].Name = "MyNewEntity";
}
</source>
<target xml:lang="pt">// Campos e propriedades de membros públicos exibidos no Game Studio Property Grid
público pré-fabricada CarPrefab;
público Vector3 SpawnPosition;
público Quaternion SpawnRotation;

anula de sobreposição pública Start()
(
    // Inicialização do script
    List&lt;Entity&gt; carEntidades = CarPrefab.Instantiate();
    
    // Adicione as entidades instantâneas à cena raiz
    SceneSystem.SceneInstance.RootScene.Entities.AddRange(carEntities);
    
    // Defina a posição e a rotação da primeira entidade na lista
    carEntities[0].Transform.Position = SpawnPosition;
    carEntities[0]. Transform.Rotation = SpawnRotation;
    
    // Opcionalmente, você pode definir um nome para a entidade
    carEntities[0]. Nome = "MyNewEntity";
}
</target>
</trans-unit>
<trans-unit id="tu166" xml:space="preserve">
<source xml:lang="en">Serialization</source>
<target xml:lang="pt">Serialização</target>
</trans-unit>
<trans-unit id="tu167" xml:space="preserve">
<source xml:lang="en">Godot</source>
<target xml:lang="pt">Deus</target>
</trans-unit>
<trans-unit id="tu168" xml:space="preserve">
<source xml:lang="en">In Godot, you need to inherit from an engine class for it to be visible in the editor. Additionally, only types known to the Godot engine can be exported.</source>
<target xml:lang="pt">Em Godot, você precisa herdar de uma classe de motor para que ele seja visível no editor. Além disso, apenas tipos conhecidos para o motor Godot podem ser exportados.</target>
</trans-unit>
<trans-unit id="tu169" xml:space="preserve">
<source xml:lang="en">Stride</source>
<target xml:lang="pt">Stride</target>
</trans-unit>
<trans-unit id="tu170" xml:space="preserve">
<source xml:lang="en">Stride takes a different approach, aiming for closer integration with C#.</source>
<target xml:lang="pt">Stride toma uma abordagem diferente, visando uma integração mais estreita com C#.</target>
</trans-unit>
<trans-unit id="tu171" xml:space="preserve">
<source xml:lang="en">Data Contract Attribute</source>
<target xml:lang="pt">Atributo de Contrato de Dados</target>
</trans-unit>
<trans-unit id="tu172" xml:space="preserve">
<source xml:lang="en">To make your class serializable within Game Studio, add the <g id="1">[DataContract]</g> attribute to your class. By default, all public members will be serialized.</source>
<target xml:lang="pt">Para tornar sua classe serializável dentro do Game Studio, adicione o atributo <g id="1">[DataContract]</g> à sua classe. Por padrão, todos os membros públicos serão serializados.</target>
</trans-unit>
<trans-unit id="tu173" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[Contrato de Dados]
classe pública MyClass
(
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu174" xml:space="preserve">
<source xml:lang="en">Data Member Attribute</source>
<target xml:lang="pt">Atributo de membro de dados</target>
</trans-unit>
<trans-unit id="tu175" xml:space="preserve">
<source xml:lang="en">If you want to be explicit about what gets serialized, you can use the <g id="1">[DataMember]</g> attribute. This is similar to Godot's <g id="2">[Export]</g> attribute.</source>
<target xml:lang="pt">Se você quiser ser explícito sobre o que é serializado, você pode usar o atributo <g id="1">[DataMember]</g>. Isso é semelhante ao atributo <g id="2">[Export]</g> de Godot.</target>
</trans-unit>
<trans-unit id="tu176" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    [DataMember]
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[Contrato de Dados]
classe pública MyClass
(
    [DataMember]
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu177" xml:space="preserve">
<source xml:lang="en">Excluding Members</source>
<target xml:lang="pt">Excluindo os membros</target>
</trans-unit>
<trans-unit id="tu178" xml:space="preserve">
<source xml:lang="en">To exclude a member from serialization, use the <g id="1">[DataMemberIgnore]</g> attribute.</source>
<target xml:lang="pt">Para excluir um membro da serialização, use o atributo <g id="1">[DataMemberIgnore]</g>.</target>
</trans-unit>
<trans-unit id="tu179" xml:space="preserve">
<source xml:lang="en">[DataContract]
public class MyClass
{
    [DataMemberIgnore]
    public int MyProperty { get; set; }
}
</source>
<target xml:lang="pt">[Contrato de Dados]
classe pública MyClass
(
    [DataMemberIgnore]
    public int MyProperty { get; set; }
}
</target>
</trans-unit>
<trans-unit id="tu180" xml:space="preserve">
<source xml:lang="en">Collections and Dictionaries</source>
<target xml:lang="pt">Coleções e dicionários</target>
</trans-unit>
<trans-unit id="tu181" xml:space="preserve">
<source xml:lang="en">Stride supports <g id="1">ICollection</g> and <g id="2">IDictionary</g> classes for serialization. Note that only primitives and enums can be used as keys in dictionaries.</source>
<target xml:lang="pt">Stride suporta classes <g id="1">ICollection</g> e <g id="2">IDictionary</g> para serialização. Note que apenas primitivos e enums podem ser usados como chaves em dicionários.</target>
</trans-unit>
<trans-unit id="tu182" xml:space="preserve">
<source xml:lang="en">In Godot you have to Export Godot Collections to be visible in the Editor.</source>
<target xml:lang="pt">Em Godot você tem que exportar coleções Godot para ser visível no Editor.</target>
</trans-unit>
<trans-unit id="tu183" xml:space="preserve">
<source xml:lang="en">Nested Serialization</source>
<target xml:lang="pt">Serialização aninhada</target>
</trans-unit>
<trans-unit id="tu184" xml:space="preserve">
<source xml:lang="en">You can serialize any class marked with <g id="1">[DataContract]</g> into the editor, including abstract classes or interfaces. The <g id="2">Stride Editor</g> will search for types that match the interfaces or abstract classes, making them eligible for serialization.</source>
<target xml:lang="pt">Você pode serializar qualquer classe marcada com <g id="1">[DataContract]</g> no editor, incluindo classes abstratas ou interfaces. O <g id="2">Stride Editor</g> procurará tipos que correspondam às interfaces ou classes abstratas, tornando-os elegíveis para serialização.</target>
</trans-unit>
<trans-unit id="tu185" xml:space="preserve">
<source xml:lang="en">Log output</source>
<target xml:lang="pt">Saída de log</target>
</trans-unit>
<trans-unit id="tu186" xml:space="preserve">
<source xml:lang="en">In Godot you can GD.Print your message. //TODO What does it mean?</source>
<target xml:lang="pt">Em Godot você pode GD. Imprima sua mensagem. //TODO O que significa?</target>
</trans-unit>
<trans-unit id="tu187" xml:space="preserve">
<source xml:lang="en">To view the log output, go to the <g id="1">Game Studio</g> toolbar and click on <g id="2">View</g>, then enable the <g id="3">Output</g> option.</source>
<target xml:lang="pt">Para visualizar a saída de log, vá para a barra de ferramentas <g id="1">Game Studio</g> e clique em <g id="2">View</g>, então ative a opção <g id="3">Output</g>.</target>
</trans-unit>
<trans-unit id="tu188" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Enable output<x id="2"/></source>
<target xml:lang="pt"><x id="1"/> Activar saída<x id="2"/></target>
</trans-unit>
<trans-unit id="tu189" xml:space="preserve">
<source xml:lang="en">Once enabled, the <g id="1">Output</g> tab will appear, typically located at the bottom of the <g id="2">Game Studio</g> interface.</source>
<target xml:lang="pt">Uma vez habilitado, a aba <g id="1">Output</g> aparecerá, tipicamente localizada na parte inferior da interface <g id="2">Game Studio</g>.</target>
</trans-unit>
<trans-unit id="tu190" xml:space="preserve">
<source xml:lang="en"><x id="1"/>Output tab<x id="2"/></source>
<target xml:lang="pt"><x id="1"/>Output tab<x id="2"/></target>
</trans-unit>
<trans-unit id="tu191" xml:space="preserve">
<source xml:lang="en">Print debug messages</source>
<target xml:lang="pt">Imprimir mensagens de depuração</target>
</trans-unit>
<trans-unit id="tu192" xml:space="preserve">
<source xml:lang="en">To print to the Visual Studio output, use:</source>
<target xml:lang="pt">Para imprimir na saída Visual Studio, use:</target>
</trans-unit>
<trans-unit id="tu193" xml:space="preserve">
<source xml:lang="en">System.Diagnostics.Debug.WriteLine("hello");
</source>
<target xml:lang="pt">System.Diagnostics.Debug.WriteLine("hello");
</target>
</trans-unit>
<trans-unit id="tu194" xml:space="preserve">
<source xml:lang="en"><x id="1"/>!Note<x id="2"/>
To print debug messages, you have to run the game from Visual Studio, not Game Studio. There's no way to print to the Game Studio output window.</source>
<target xml:lang="pt"><x id="1"/>!Note<x id="2"/>
Para imprimir mensagens de depuração, você tem que executar o jogo do Visual Studio, não Game Studio. Não há como imprimir na janela de saída do Game Studio.</target>
</trans-unit>
</body>
</file>
</xliff>